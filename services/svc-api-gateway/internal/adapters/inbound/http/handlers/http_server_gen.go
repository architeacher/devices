// Package handlers provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package handlers

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	PasetoAuthScopes = "PasetoAuth.Scopes"
)

// Defines values for AppliedFiltersState.
const (
	AppliedFiltersStateAvailable AppliedFiltersState = "available"
	AppliedFiltersStateInUse     AppliedFiltersState = "in-use"
	AppliedFiltersStateInactive  AppliedFiltersState = "inactive"
)

// Defines values for CacheDependencyCheckStatus.
const (
	CacheDependencyCheckStatusDegraded CacheDependencyCheckStatus = "degraded"
	CacheDependencyCheckStatusDown     CacheDependencyCheckStatus = "down"
	CacheDependencyCheckStatusUnknown  CacheDependencyCheckStatus = "unknown"
	CacheDependencyCheckStatusUp       CacheDependencyCheckStatus = "up"
)

// Defines values for CreateDeviceRequestState.
const (
	CreateDeviceRequestStateAvailable CreateDeviceRequestState = "available"
	CreateDeviceRequestStateInUse     CreateDeviceRequestState = "in-use"
	CreateDeviceRequestStateInactive  CreateDeviceRequestState = "inactive"
)

// Defines values for DependencyCheckStatus.
const (
	DependencyCheckStatusDegraded DependencyCheckStatus = "degraded"
	DependencyCheckStatusDown     DependencyCheckStatus = "down"
	DependencyCheckStatusUnknown  DependencyCheckStatus = "unknown"
	DependencyCheckStatusUp       DependencyCheckStatus = "up"
)

// Defines values for DeviceState.
const (
	DeviceStateAvailable DeviceState = "available"
	DeviceStateInUse     DeviceState = "in-use"
	DeviceStateInactive  DeviceState = "inactive"
)

// Defines values for DeviceListResponseDataState.
const (
	DeviceListResponseDataStateAvailable DeviceListResponseDataState = "available"
	DeviceListResponseDataStateInUse     DeviceListResponseDataState = "in-use"
	DeviceListResponseDataStateInactive  DeviceListResponseDataState = "inactive"
)

// Defines values for DeviceListResponseFiltersState.
const (
	DeviceListResponseFiltersStateAvailable DeviceListResponseFiltersState = "available"
	DeviceListResponseFiltersStateInUse     DeviceListResponseFiltersState = "in-use"
	DeviceListResponseFiltersStateInactive  DeviceListResponseFiltersState = "inactive"
)

// Defines values for DeviceResponseDataState.
const (
	DeviceResponseDataStateAvailable DeviceResponseDataState = "available"
	DeviceResponseDataStateInUse     DeviceResponseDataState = "in-use"
	DeviceResponseDataStateInactive  DeviceResponseDataState = "inactive"
)

// Defines values for HealthResponseChecksInfraCacheStatus.
const (
	HealthResponseChecksInfraCacheStatusDegraded HealthResponseChecksInfraCacheStatus = "degraded"
	HealthResponseChecksInfraCacheStatusDown     HealthResponseChecksInfraCacheStatus = "down"
	HealthResponseChecksInfraCacheStatusUnknown  HealthResponseChecksInfraCacheStatus = "unknown"
	HealthResponseChecksInfraCacheStatusUp       HealthResponseChecksInfraCacheStatus = "up"
)

// Defines values for HealthResponseChecksInfraStorageStatus.
const (
	HealthResponseChecksInfraStorageStatusDegraded HealthResponseChecksInfraStorageStatus = "degraded"
	HealthResponseChecksInfraStorageStatusDown     HealthResponseChecksInfraStorageStatus = "down"
	HealthResponseChecksInfraStorageStatusUnknown  HealthResponseChecksInfraStorageStatus = "unknown"
	HealthResponseChecksInfraStorageStatusUp       HealthResponseChecksInfraStorageStatus = "up"
)

// Defines values for HealthResponseChecksServicesDevicesStatus.
const (
	HealthResponseChecksServicesDevicesStatusDegraded HealthResponseChecksServicesDevicesStatus = "degraded"
	HealthResponseChecksServicesDevicesStatusDown     HealthResponseChecksServicesDevicesStatus = "down"
	HealthResponseChecksServicesDevicesStatusUnknown  HealthResponseChecksServicesDevicesStatus = "unknown"
	HealthResponseChecksServicesDevicesStatusUp       HealthResponseChecksServicesDevicesStatus = "up"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded    HealthResponseStatus = "degraded"
	HealthResponseStatusDown        HealthResponseStatus = "down"
	HealthResponseStatusMaintenance HealthResponseStatus = "maintenance"
	HealthResponseStatusOk          HealthResponseStatus = "ok"
)

// Defines values for LivenessResponseStatus.
const (
	LivenessResponseStatusDegraded    LivenessResponseStatus = "degraded"
	LivenessResponseStatusDown        LivenessResponseStatus = "down"
	LivenessResponseStatusMaintenance LivenessResponseStatus = "maintenance"
	LivenessResponseStatusOk          LivenessResponseStatus = "ok"
)

// Defines values for PatchDeviceRequestState.
const (
	PatchDeviceRequestStateAvailable PatchDeviceRequestState = "available"
	PatchDeviceRequestStateInUse     PatchDeviceRequestState = "in-use"
	PatchDeviceRequestStateInactive  PatchDeviceRequestState = "inactive"
)

// Defines values for ReadinessResponseChecksInfraCacheStatus.
const (
	ReadinessResponseChecksInfraCacheStatusDegraded ReadinessResponseChecksInfraCacheStatus = "degraded"
	ReadinessResponseChecksInfraCacheStatusDown     ReadinessResponseChecksInfraCacheStatus = "down"
	ReadinessResponseChecksInfraCacheStatusUnknown  ReadinessResponseChecksInfraCacheStatus = "unknown"
	ReadinessResponseChecksInfraCacheStatusUp       ReadinessResponseChecksInfraCacheStatus = "up"
)

// Defines values for ReadinessResponseChecksInfraStorageStatus.
const (
	ReadinessResponseChecksInfraStorageStatusDegraded ReadinessResponseChecksInfraStorageStatus = "degraded"
	ReadinessResponseChecksInfraStorageStatusDown     ReadinessResponseChecksInfraStorageStatus = "down"
	ReadinessResponseChecksInfraStorageStatusUnknown  ReadinessResponseChecksInfraStorageStatus = "unknown"
	ReadinessResponseChecksInfraStorageStatusUp       ReadinessResponseChecksInfraStorageStatus = "up"
)

// Defines values for ReadinessResponseChecksServicesDevicesStatus.
const (
	ReadinessResponseChecksServicesDevicesStatusDegraded ReadinessResponseChecksServicesDevicesStatus = "degraded"
	ReadinessResponseChecksServicesDevicesStatusDown     ReadinessResponseChecksServicesDevicesStatus = "down"
	ReadinessResponseChecksServicesDevicesStatusUnknown  ReadinessResponseChecksServicesDevicesStatus = "unknown"
	ReadinessResponseChecksServicesDevicesStatusUp       ReadinessResponseChecksServicesDevicesStatus = "up"
)

// Defines values for ReadinessResponseStatus.
const (
	Degraded    ReadinessResponseStatus = "degraded"
	Down        ReadinessResponseStatus = "down"
	Maintenance ReadinessResponseStatus = "maintenance"
	Ok          ReadinessResponseStatus = "ok"
)

// Defines values for UpdateDeviceRequestState.
const (
	UpdateDeviceRequestStateAvailable UpdateDeviceRequestState = "available"
	UpdateDeviceRequestStateInUse     UpdateDeviceRequestState = "in-use"
	UpdateDeviceRequestStateInactive  UpdateDeviceRequestState = "inactive"
)

// Defines values for ApiVersionHeader.
const (
	ApiVersionHeaderV1 ApiVersionHeader = "v1"
)

// Defines values for StateFilterParam.
const (
	StateFilterParamAvailable StateFilterParam = "available"
	StateFilterParamInUse     StateFilterParam = "in-use"
	StateFilterParamInactive  StateFilterParam = "inactive"
)

// Defines values for ListDevicesParamsState.
const (
	ListDevicesParamsStateAvailable ListDevicesParamsState = "available"
	ListDevicesParamsStateInUse     ListDevicesParamsState = "in-use"
	ListDevicesParamsStateInactive  ListDevicesParamsState = "inactive"
)

// Defines values for ListDevicesParamsAPIVersion.
const (
	ListDevicesParamsAPIVersionV1 ListDevicesParamsAPIVersion = "v1"
)

// Defines values for HeadDevicesParamsState.
const (
	HeadDevicesParamsStateAvailable HeadDevicesParamsState = "available"
	HeadDevicesParamsStateInUse     HeadDevicesParamsState = "in-use"
	HeadDevicesParamsStateInactive  HeadDevicesParamsState = "inactive"
)

// Defines values for HeadDevicesParamsAPIVersion.
const (
	HeadDevicesParamsAPIVersionV1 HeadDevicesParamsAPIVersion = "v1"
)

// Defines values for CreateDeviceParamsAPIVersion.
const (
	CreateDeviceParamsAPIVersionV1 CreateDeviceParamsAPIVersion = "v1"
)

// Defines values for CreateDeviceJSONBodyState.
const (
	CreateDeviceJSONBodyStateAvailable CreateDeviceJSONBodyState = "available"
	CreateDeviceJSONBodyStateInUse     CreateDeviceJSONBodyState = "in-use"
	CreateDeviceJSONBodyStateInactive  CreateDeviceJSONBodyState = "inactive"
)

// Defines values for DeleteDeviceParamsAPIVersion.
const (
	DeleteDeviceParamsAPIVersionV1 DeleteDeviceParamsAPIVersion = "v1"
)

// Defines values for GetDeviceParamsAPIVersion.
const (
	GetDeviceParamsAPIVersionV1 GetDeviceParamsAPIVersion = "v1"
)

// Defines values for HeadDeviceParamsAPIVersion.
const (
	HeadDeviceParamsAPIVersionV1 HeadDeviceParamsAPIVersion = "v1"
)

// Defines values for PatchDeviceParamsAPIVersion.
const (
	PatchDeviceParamsAPIVersionV1 PatchDeviceParamsAPIVersion = "v1"
)

// Defines values for PatchDeviceJSONBodyState.
const (
	PatchDeviceJSONBodyStateAvailable PatchDeviceJSONBodyState = "available"
	PatchDeviceJSONBodyStateInUse     PatchDeviceJSONBodyState = "in-use"
	PatchDeviceJSONBodyStateInactive  PatchDeviceJSONBodyState = "inactive"
)

// Defines values for UpdateDeviceParamsAPIVersion.
const (
	V1 UpdateDeviceParamsAPIVersion = "v1"
)

// Defines values for UpdateDeviceJSONBodyState.
const (
	UpdateDeviceJSONBodyStateAvailable UpdateDeviceJSONBodyState = "available"
	UpdateDeviceJSONBodyStateInUse     UpdateDeviceJSONBodyState = "in-use"
	UpdateDeviceJSONBodyStateInactive  UpdateDeviceJSONBodyState = "inactive"
)

// AppliedFilters Filters that were applied to this request
type AppliedFilters struct {
	// Brand Brand filter that was applied
	Brand *string `json:"brand"`

	// State State filter that was applied
	State *AppliedFiltersState `json:"state"`
}

// AppliedFiltersState State filter that was applied
type AppliedFiltersState string

// CacheDependencyCheck defines model for CacheDependencyCheck.
type CacheDependencyCheck struct {
	// Details Cache-specific details
	Details *struct {
		// PoolStats Connection pool statistics
		PoolStats *struct {
			// Hits Number of successful pool hits
			Hits *int `json:"hits,omitempty"`

			// IdleConnections Number of idle connections in the pool
			IdleConnections *int `json:"idleConnections,omitempty"`

			// Misses Number of pool misses
			Misses *int `json:"misses,omitempty"`

			// StaleConnections Number of stale connections removed from the pool
			StaleConnections *int `json:"staleConnections,omitempty"`

			// Timeouts Number of connection timeouts
			Timeouts *int `json:"timeouts,omitempty"`

			// TotalConnections Total number of connections in the pool
			TotalConnections *int `json:"totalConnections,omitempty"`

			// WaitCount Number of times a connection was waited for
			WaitCount *int `json:"waitCount,omitempty"`

			// WaitDurationNs Total time spent waiting for connections in nanoseconds
			WaitDurationNs *int `json:"waitDurationNs,omitempty"`
		} `json:"poolStats,omitempty"`

		// TotalKeys Total number of keys in the cache
		TotalKeys *int `json:"totalKeys,omitempty"`
	} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status CacheDependencyCheckStatus `json:"status"`
}

// CacheDependencyCheckStatus The status of the dependency
type CacheDependencyCheckStatus string

// CreateDeviceRequest Request body for creating a new device
type CreateDeviceRequest struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State Initial state of the device (defaults to "available" if not provided)
	State *CreateDeviceRequestState `json:"state,omitempty"`
}

// CreateDeviceRequestState Initial state of the device (defaults to "available" if not provided)
type CreateDeviceRequestState string

// DependencyCheck Status of a single dependency
type DependencyCheck struct {
	// Details Additional dependency-specific details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status DependencyCheckStatus `json:"status"`
}

// DependencyCheckStatus The status of the dependency
type DependencyCheckStatus string

// Device A device resource
type Device struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// CreatedAt Timestamp when the device was created (immutable)
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique identifier for the device (UUID v7)
	Id openapi_types.UUID `json:"id"`

	// Links HATEOAS links for device navigation
	Links *struct {
		// Self Link to this device resource
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`

	// UpdatedAt Timestamp when the device was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// DeviceState The current state of the device
type DeviceState string

// DeviceLinks HATEOAS links for device navigation
type DeviceLinks struct {
	// Self Link to this device resource
	Self *string `json:"self,omitempty"`
}

// DeviceListResponse Response containing a paginated list of devices
type DeviceListResponse struct {
	// Data List of devices
	Data []struct {
		// Brand The brand/manufacturer of the device
		Brand string `json:"brand"`

		// CreatedAt Timestamp when the device was created (immutable)
		CreatedAt time.Time `json:"createdAt"`

		// Id Unique identifier for the device (UUID v7)
		Id openapi_types.UUID `json:"id"`

		// Links HATEOAS links for device navigation
		Links *struct {
			// Self Link to this device resource
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Name The name of the device
		Name string `json:"name"`

		// State The current state of the device
		State DeviceListResponseDataState `json:"state"`

		// UpdatedAt Timestamp when the device was last updated
		UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	} `json:"data"`

	// Filters Filters that were applied to this request
	Filters *struct {
		// Brand Brand filter that was applied
		Brand *string `json:"brand"`

		// State State filter that was applied
		State *DeviceListResponseFiltersState `json:"state"`
	} `json:"filters,omitempty"`

	// Pagination Pagination metadata for list responses
	Pagination struct {
		// HasNext Whether there is a next page
		HasNext *bool `json:"hasNext,omitempty"`

		// HasPrevious Whether there is a previous page
		HasPrevious *bool `json:"hasPrevious,omitempty"`

		// Links HATEOAS links for pagination navigation
		Links *struct {
			// First Link to the first page
			First *string `json:"first,omitempty"`

			// Last Link to the last page
			Last *string `json:"last,omitempty"`

			// Next Link to the next page (null if on last page)
			Next *string `json:"next"`

			// Previous Link to the previous page (null if on first page)
			Previous *string `json:"previous"`

			// Self Link to the current page
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Page Current page number (1-indexed)
		Page int `json:"page"`

		// Size Number of items per page
		Size int `json:"size"`

		// TotalItems Total number of items across all pages
		TotalItems int `json:"totalItems"`

		// TotalPages Total number of pages
		TotalPages int `json:"totalPages"`
	} `json:"pagination"`
}

// DeviceListResponseDataState The current state of the device
type DeviceListResponseDataState string

// DeviceListResponseFiltersState State filter that was applied
type DeviceListResponseFiltersState string

// DeviceResponse Response containing a single device
type DeviceResponse struct {
	// Data A device resource
	Data struct {
		// Brand The brand/manufacturer of the device
		Brand string `json:"brand"`

		// CreatedAt Timestamp when the device was created (immutable)
		CreatedAt time.Time `json:"createdAt"`

		// Id Unique identifier for the device (UUID v7)
		Id openapi_types.UUID `json:"id"`

		// Links HATEOAS links for device navigation
		Links *struct {
			// Self Link to this device resource
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Name The name of the device
		Name string `json:"name"`

		// State The current state of the device
		State DeviceResponseDataState `json:"state"`

		// UpdatedAt Timestamp when the device was last updated
		UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	} `json:"data"`
}

// DeviceResponseDataState The current state of the device
type DeviceResponseDataState string

// ErrorDetail Detailed information about a specific error
type ErrorDetail struct {
	// Code Machine-readable error code for this specific error
	Code *string `json:"code,omitempty"`

	// Field The field that caused the error
	Field string `json:"field"`

	// Message Description of what is wrong with the field
	Message string `json:"message"`
}

// ErrorResponse Standard error response format
type ErrorResponse struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// HealthResponse Comprehensive health check response with system metrics
type HealthResponse struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *struct {
				// Details Cache-specific details
				Details *struct {
					// PoolStats Connection pool statistics
					PoolStats *struct {
						// Hits Number of successful pool hits
						Hits *int `json:"hits,omitempty"`

						// IdleConnections Number of idle connections in the pool
						IdleConnections *int `json:"idleConnections,omitempty"`

						// Misses Number of pool misses
						Misses *int `json:"misses,omitempty"`

						// StaleConnections Number of stale connections removed from the pool
						StaleConnections *int `json:"staleConnections,omitempty"`

						// Timeouts Number of connection timeouts
						Timeouts *int `json:"timeouts,omitempty"`

						// TotalConnections Total number of connections in the pool
						TotalConnections *int `json:"totalConnections,omitempty"`

						// WaitCount Number of times a connection was waited for
						WaitCount *int `json:"waitCount,omitempty"`

						// WaitDurationNs Total time spent waiting for connections in nanoseconds
						WaitDurationNs *int `json:"waitDurationNs,omitempty"`
					} `json:"poolStats,omitempty"`

					// TotalKeys Total number of keys in the cache
					TotalKeys *int `json:"totalKeys,omitempty"`
				} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksInfraCacheStatus `json:"status"`
			} `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksInfraStorageStatus `json:"status"`
			} `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksServicesDevicesStatus `json:"status"`
			} `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall health status of the service
	Status HealthResponseStatus `json:"status"`

	// System System resource information
	System *struct {
		// CpuCores Number of CPU cores available
		CpuCores *int `json:"cpuCores,omitempty"`

		// Goroutines Number of active goroutines
		Goroutines *int `json:"goroutines,omitempty"`

		// Memory Memory usage information
		Memory *struct {
			// AllocMb Current memory allocation in MB
			AllocMb *float32 `json:"allocMb,omitempty"`

			// GcCycles Number of completed GC cycles
			GcCycles *int `json:"gcCycles,omitempty"`

			// SysMb Total memory obtained from the OS in MB
			SysMb *float32 `json:"sysMb,omitempty"`

			// TotalAllocMb Total memory allocated since start in MB
			TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
		} `json:"memory,omitempty"`
	} `json:"system,omitempty"`

	// Timestamp Timestamp of the health check
	Timestamp time.Time `json:"timestamp"`

	// Uptime Service uptime information
	Uptime struct {
		// Duration Human-readable uptime duration
		Duration string `json:"duration"`

		// DurationSeconds Uptime in seconds
		DurationSeconds *int `json:"durationSeconds,omitempty"`

		// StartedAt Timestamp when the service started
		StartedAt time.Time `json:"startedAt"`
	} `json:"uptime"`

	// Version Version information about the service
	Version struct {
		// Api API version
		Api string `json:"api"`

		// Build Build version or commit hash
		Build string `json:"build"`

		// Go Go runtime version
		Go *string `json:"go,omitempty"`
	} `json:"version"`
}

// HealthResponseChecksInfraCacheStatus The status of the dependency
type HealthResponseChecksInfraCacheStatus string

// HealthResponseChecksInfraStorageStatus The status of the dependency
type HealthResponseChecksInfraStorageStatus string

// HealthResponseChecksServicesDevicesStatus The status of the dependency
type HealthResponseChecksServicesDevicesStatus string

// HealthResponseStatus The overall health status of the service
type HealthResponseStatus string

// LivenessResponse Liveness probe response
type LivenessResponse struct {
	// Status The liveness status of the service
	Status LivenessResponseStatus `json:"status"`

	// Timestamp Timestamp of the liveness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version string `json:"version"`
}

// LivenessResponseStatus The liveness status of the service
type LivenessResponseStatus string

// MemoryInfo Memory usage information
type MemoryInfo struct {
	// AllocMb Current memory allocation in MB
	AllocMb *float32 `json:"allocMb,omitempty"`

	// GcCycles Number of completed GC cycles
	GcCycles *int `json:"gcCycles,omitempty"`

	// SysMb Total memory obtained from the OS in MB
	SysMb *float32 `json:"sysMb,omitempty"`

	// TotalAllocMb Total memory allocated since start in MB
	TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
}

// Pagination Pagination metadata for list responses
type Pagination struct {
	// HasNext Whether there is a next page
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrevious Whether there is a previous page
	HasPrevious *bool `json:"hasPrevious,omitempty"`

	// Links HATEOAS links for pagination navigation
	Links *struct {
		// First Link to the first page
		First *string `json:"first,omitempty"`

		// Last Link to the last page
		Last *string `json:"last,omitempty"`

		// Next Link to the next page (null if on last page)
		Next *string `json:"next"`

		// Previous Link to the previous page (null if on first page)
		Previous *string `json:"previous"`

		// Self Link to the current page
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`

	// Page Current page number (1-indexed)
	Page int `json:"page"`

	// Size Number of items per page
	Size int `json:"size"`

	// TotalItems Total number of items across all pages
	TotalItems int `json:"totalItems"`

	// TotalPages Total number of pages
	TotalPages int `json:"totalPages"`
}

// PaginationLinks HATEOAS links for pagination navigation
type PaginationLinks struct {
	// First Link to the first page
	First *string `json:"first,omitempty"`

	// Last Link to the last page
	Last *string `json:"last,omitempty"`

	// Next Link to the next page (null if on last page)
	Next *string `json:"next"`

	// Previous Link to the previous page (null if on first page)
	Previous *string `json:"previous"`

	// Self Link to the current page
	Self *string `json:"self,omitempty"`
}

// PatchDeviceRequest Request body for partially updating a device (PATCH)
type PatchDeviceRequest struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The state of the device
	State *PatchDeviceRequestState `json:"state,omitempty"`
}

// PatchDeviceRequestState The state of the device
type PatchDeviceRequestState string

// PoolStats Connection pool statistics
type PoolStats struct {
	// Hits Number of successful pool hits
	Hits *int `json:"hits,omitempty"`

	// IdleConnections Number of idle connections in the pool
	IdleConnections *int `json:"idleConnections,omitempty"`

	// Misses Number of pool misses
	Misses *int `json:"misses,omitempty"`

	// StaleConnections Number of stale connections removed from the pool
	StaleConnections *int `json:"staleConnections,omitempty"`

	// Timeouts Number of connection timeouts
	Timeouts *int `json:"timeouts,omitempty"`

	// TotalConnections Total number of connections in the pool
	TotalConnections *int `json:"totalConnections,omitempty"`

	// WaitCount Number of times a connection was waited for
	WaitCount *int `json:"waitCount,omitempty"`

	// WaitDurationNs Total time spent waiting for connections in nanoseconds
	WaitDurationNs *int `json:"waitDurationNs,omitempty"`
}

// ReadinessResponse Readiness probe response with dependency status
type ReadinessResponse struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *struct {
				// Details Cache-specific details
				Details *struct {
					// PoolStats Connection pool statistics
					PoolStats *struct {
						// Hits Number of successful pool hits
						Hits *int `json:"hits,omitempty"`

						// IdleConnections Number of idle connections in the pool
						IdleConnections *int `json:"idleConnections,omitempty"`

						// Misses Number of pool misses
						Misses *int `json:"misses,omitempty"`

						// StaleConnections Number of stale connections removed from the pool
						StaleConnections *int `json:"staleConnections,omitempty"`

						// Timeouts Number of connection timeouts
						Timeouts *int `json:"timeouts,omitempty"`

						// TotalConnections Total number of connections in the pool
						TotalConnections *int `json:"totalConnections,omitempty"`

						// WaitCount Number of times a connection was waited for
						WaitCount *int `json:"waitCount,omitempty"`

						// WaitDurationNs Total time spent waiting for connections in nanoseconds
						WaitDurationNs *int `json:"waitDurationNs,omitempty"`
					} `json:"poolStats,omitempty"`

					// TotalKeys Total number of keys in the cache
					TotalKeys *int `json:"totalKeys,omitempty"`
				} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksInfraCacheStatus `json:"status"`
			} `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksInfraStorageStatus `json:"status"`
			} `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksServicesDevicesStatus `json:"status"`
			} `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall readiness status of the service
	Status ReadinessResponseStatus `json:"status"`

	// Timestamp Timestamp of the readiness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version (optional)
	Version *string `json:"version,omitempty"`
}

// ReadinessResponseChecksInfraCacheStatus The status of the dependency
type ReadinessResponseChecksInfraCacheStatus string

// ReadinessResponseChecksInfraStorageStatus The status of the dependency
type ReadinessResponseChecksInfraStorageStatus string

// ReadinessResponseChecksServicesDevicesStatus The status of the dependency
type ReadinessResponseChecksServicesDevicesStatus string

// ReadinessResponseStatus The overall readiness status of the service
type ReadinessResponseStatus string

// SystemInfo System resource information
type SystemInfo struct {
	// CpuCores Number of CPU cores available
	CpuCores *int `json:"cpuCores,omitempty"`

	// Goroutines Number of active goroutines
	Goroutines *int `json:"goroutines,omitempty"`

	// Memory Memory usage information
	Memory *struct {
		// AllocMb Current memory allocation in MB
		AllocMb *float32 `json:"allocMb,omitempty"`

		// GcCycles Number of completed GC cycles
		GcCycles *int `json:"gcCycles,omitempty"`

		// SysMb Total memory obtained from the OS in MB
		SysMb *float32 `json:"sysMb,omitempty"`

		// TotalAllocMb Total memory allocated since start in MB
		TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
	} `json:"memory,omitempty"`
}

// UpdateDeviceRequest Request body for fully updating a device (PUT)
type UpdateDeviceRequest struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The state of the device
	State UpdateDeviceRequestState `json:"state"`
}

// UpdateDeviceRequestState The state of the device
type UpdateDeviceRequestState string

// UptimeInfo Service uptime information
type UptimeInfo struct {
	// Duration Human-readable uptime duration
	Duration string `json:"duration"`

	// DurationSeconds Uptime in seconds
	DurationSeconds *int `json:"durationSeconds,omitempty"`

	// StartedAt Timestamp when the service started
	StartedAt time.Time `json:"startedAt"`
}

// VersionInfo Version information about the service
type VersionInfo struct {
	// Api API version
	Api string `json:"api"`

	// Build Build version or commit hash
	Build string `json:"build"`

	// Go Go runtime version
	Go *string `json:"go,omitempty"`
}

// AcceptEncodingHeader defines model for AcceptEncodingHeader.
type AcceptEncodingHeader = string

// AcceptHeader defines model for AcceptHeader.
type AcceptHeader = string

// ApiVersionHeader defines model for ApiVersionHeader.
type ApiVersionHeader string

// AuthorizationHeader defines model for AuthorizationHeader.
type AuthorizationHeader = string

// BrandFilterParam defines model for BrandFilterParam.
type BrandFilterParam = string

// DeviceIdParam defines model for DeviceIdParam.
type DeviceIdParam = openapi_types.UUID

// FieldsParam defines model for FieldsParam.
type FieldsParam = string

// IdempotencyKeyHeader defines model for IdempotencyKeyHeader.
type IdempotencyKeyHeader = openapi_types.UUID

// IfMatchHeader defines model for IfMatchHeader.
type IfMatchHeader = string

// IfNoneMatchHeader defines model for IfNoneMatchHeader.
type IfNoneMatchHeader = string

// PageParam defines model for PageParam.
type PageParam = int

// RequestIdHeader defines model for RequestIdHeader.
type RequestIdHeader = openapi_types.UUID

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = string

// StateFilterParam The current state of the device
type StateFilterParam string

// TraceparentHeader defines model for TraceparentHeader.
type TraceparentHeader = string

// TracestateHeader defines model for TracestateHeader.
type TracestateHeader = string

// BadRequest Standard error response format
type BadRequest struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// Conflict Standard error response format
type Conflict struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// NotAcceptable Standard error response format
type NotAcceptable struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// NotFound Standard error response format
type NotFound struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// PreconditionFailed Standard error response format
type PreconditionFailed struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// RateLimit Standard error response format
type RateLimit struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ServerError Standard error response format
type ServerError struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// Unauthorized Standard error response format
type Unauthorized struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// UnprocessableEntity Standard error response format
type UnprocessableEntity struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter devices by brand (case-insensitive, partial match)
	Brand *string `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter devices by state
	State *ListDevicesParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Sort Field to sort results by. Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ListDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// XRequestId Unique request identifier for tracing and debugging purposes.
	// If not provided, the server will generate one.
	XRequestId *openapi_types.UUID `json:"X-Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// ListDevicesParamsState defines parameters for ListDevices.
type ListDevicesParamsState string

// ListDevicesParamsAPIVersion defines parameters for ListDevices.
type ListDevicesParamsAPIVersion string

// HeadDevicesParams defines parameters for HeadDevices.
type HeadDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter devices by brand (case-insensitive, partial match)
	Brand *string `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter devices by state
	State *HeadDevicesParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Sort Field to sort results by. Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// XRequestId Unique request identifier for tracing and debugging purposes.
	// If not provided, the server will generate one.
	XRequestId *openapi_types.UUID `json:"X-Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadDevicesParamsState defines parameters for HeadDevices.
type HeadDevicesParamsState string

// HeadDevicesParamsAPIVersion defines parameters for HeadDevices.
type HeadDevicesParamsAPIVersion string

// CreateDeviceJSONBody defines parameters for CreateDevice.
type CreateDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State Initial state of the device (defaults to "available" if not provided)
	State *CreateDeviceJSONBodyState `json:"state,omitempty"`
}

// CreateDeviceParams defines parameters for CreateDevice.
type CreateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *CreateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// XRequestId Unique request identifier for tracing and debugging purposes.
	// If not provided, the server will generate one.
	XRequestId *openapi_types.UUID `json:"X-Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IdempotencyKey Unique key to ensure idempotent POST requests.
	// If the same key is sent again within the TTL window (24 hours),
	// the server returns the cached response instead of creating a duplicate.
	//
	// **Requirements:**
	// - Must be a valid UUID v4
	// - Must be unique per logical operation
	// - Cached for 24 hours
	IdempotencyKey openapi_types.UUID `json:"Idempotency-Key"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// CreateDeviceParamsAPIVersion defines parameters for CreateDevice.
type CreateDeviceParamsAPIVersion string

// CreateDeviceJSONBodyState defines parameters for CreateDevice.
type CreateDeviceJSONBodyState string

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *DeleteDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// XRequestId Unique request identifier for tracing and debugging purposes.
	// If not provided, the server will generate one.
	XRequestId *openapi_types.UUID `json:"X-Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`
}

// DeleteDeviceParamsAPIVersion defines parameters for DeleteDevice.
type DeleteDeviceParamsAPIVersion string

// GetDeviceParams defines parameters for GetDevice.
type GetDeviceParams struct {
	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *GetDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// XRequestId Unique request identifier for tracing and debugging purposes.
	// If not provided, the server will generate one.
	XRequestId *openapi_types.UUID `json:"X-Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// GetDeviceParamsAPIVersion defines parameters for GetDevice.
type GetDeviceParamsAPIVersion string

// HeadDeviceParams defines parameters for HeadDevice.
type HeadDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// XRequestId Unique request identifier for tracing and debugging purposes.
	// If not provided, the server will generate one.
	XRequestId *openapi_types.UUID `json:"X-Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadDeviceParamsAPIVersion defines parameters for HeadDevice.
type HeadDeviceParamsAPIVersion string

// PatchDeviceJSONBody defines parameters for PatchDevice.
type PatchDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The state of the device
	State *PatchDeviceJSONBodyState `json:"state,omitempty"`
}

// PatchDeviceParams defines parameters for PatchDevice.
type PatchDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *PatchDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// XRequestId Unique request identifier for tracing and debugging purposes.
	// If not provided, the server will generate one.
	XRequestId *openapi_types.UUID `json:"X-Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// PatchDeviceParamsAPIVersion defines parameters for PatchDevice.
type PatchDeviceParamsAPIVersion string

// PatchDeviceJSONBodyState defines parameters for PatchDevice.
type PatchDeviceJSONBodyState string

// UpdateDeviceJSONBody defines parameters for UpdateDevice.
type UpdateDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The state of the device
	State UpdateDeviceJSONBodyState `json:"state"`
}

// UpdateDeviceParams defines parameters for UpdateDevice.
type UpdateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *UpdateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// XRequestId Unique request identifier for tracing and debugging purposes.
	// If not provided, the server will generate one.
	XRequestId *openapi_types.UUID `json:"X-Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// UpdateDeviceParamsAPIVersion defines parameters for UpdateDevice.
type UpdateDeviceParamsAPIVersion string

// UpdateDeviceJSONBodyState defines parameters for UpdateDevice.
type UpdateDeviceJSONBodyState string

// CreateDeviceJSONRequestBody defines body for CreateDevice for application/json ContentType.
type CreateDeviceJSONRequestBody CreateDeviceJSONBody

// PatchDeviceJSONRequestBody defines body for PatchDevice for application/json ContentType.
type PatchDeviceJSONRequestBody PatchDeviceJSONBody

// UpdateDeviceJSONRequestBody defines body for UpdateDevice for application/json ContentType.
type UpdateDeviceJSONRequestBody UpdateDeviceJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all devices
	// (GET /devices)
	ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams)
	// Get devices collection metadata
	// (HEAD /devices)
	HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams)
	// Get allowed methods for devices collection
	// (OPTIONS /devices)
	OptionsDevices(w http.ResponseWriter, r *http.Request)
	// Create a new device
	// (POST /devices)
	CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams)
	// Delete a device
	// (DELETE /devices/{deviceId})
	DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params DeleteDeviceParams)
	// Get a device by ID
	// (GET /devices/{deviceId})
	GetDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params GetDeviceParams)
	// Get device metadata
	// (HEAD /devices/{deviceId})
	HeadDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params HeadDeviceParams)
	// Get allowed methods for device resource
	// (OPTIONS /devices/{deviceId})
	OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID)
	// Partially update a device
	// (PATCH /devices/{deviceId})
	PatchDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params PatchDeviceParams)
	// Fully update a device
	// (PUT /devices/{deviceId})
	UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params UpdateDeviceParams)
	// Health check
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// Liveness probe
	// (GET /liveness)
	LivenessCheck(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /readiness)
	ReadinessCheck(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List all devices
// (GET /devices)
func (_ Unimplemented) ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get devices collection metadata
// (HEAD /devices)
func (_ Unimplemented) HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for devices collection
// (OPTIONS /devices)
func (_ Unimplemented) OptionsDevices(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new device
// (POST /devices)
func (_ Unimplemented) CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a device
// (DELETE /devices/{deviceId})
func (_ Unimplemented) DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params DeleteDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a device by ID
// (GET /devices/{deviceId})
func (_ Unimplemented) GetDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params GetDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get device metadata
// (HEAD /devices/{deviceId})
func (_ Unimplemented) HeadDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params HeadDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for device resource
// (OPTIONS /devices/{deviceId})
func (_ Unimplemented) OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Partially update a device
// (PATCH /devices/{deviceId})
func (_ Unimplemented) PatchDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params PatchDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fully update a device
// (PUT /devices/{deviceId})
func (_ Unimplemented) UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params UpdateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /liveness)
func (_ Unimplemented) LivenessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /readiness)
func (_ Unimplemented) ReadinessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", true, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ListDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-Id", valueList[0], &XRequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevices operation middleware
func (siw *ServerInterfaceWrapper) HeadDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", true, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-Id", valueList[0], &XRequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevices operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevices(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevices(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateDevice operation middleware
func (siw *ServerInterfaceWrapper) CreateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion CreateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-Id", valueList[0], &XRequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Required header parameter "Idempotency-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Idempotency-Key")]; found {
		var IdempotencyKey openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Idempotency-Key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Idempotency-Key", valueList[0], &IdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Idempotency-Key", Err: err})
			return
		}

		params.IdempotencyKey = IdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter Idempotency-Key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Idempotency-Key", Err: err})
		return
	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDevice(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDevice operation middleware
func (siw *ServerInterfaceWrapper) DeleteDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion DeleteDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-Id", valueList[0], &XRequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDevice operation middleware
func (siw *ServerInterfaceWrapper) GetDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDeviceParams

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion GetDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-Id", valueList[0], &XRequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevice operation middleware
func (siw *ServerInterfaceWrapper) HeadDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-Id", valueList[0], &XRequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevice operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevice(w, r, deviceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchDevice operation middleware
func (siw *ServerInterfaceWrapper) PatchDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion PatchDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-Id", valueList[0], &XRequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateDevice operation middleware
func (siw *ServerInterfaceWrapper) UpdateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion UpdateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "X-Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Request-Id")]; found {
		var XRequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Request-Id", valueList[0], &XRequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-Request-Id", Err: err})
			return
		}

		params.XRequestId = &XRequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LivenessCheck operation middleware
func (siw *ServerInterfaceWrapper) LivenessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LivenessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadinessCheck operation middleware
func (siw *ServerInterfaceWrapper) ReadinessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadinessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices", wrapper.ListDevices)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices", wrapper.HeadDevices)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices", wrapper.OptionsDevices)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/devices", wrapper.CreateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/devices/{deviceId}", wrapper.DeleteDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices/{deviceId}", wrapper.GetDevice)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices/{deviceId}", wrapper.HeadDevice)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices/{deviceId}", wrapper.OptionsDevice)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/devices/{deviceId}", wrapper.PatchDevice)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/devices/{deviceId}", wrapper.UpdateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/liveness", wrapper.LivenessCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/readiness", wrapper.ReadinessCheck)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
