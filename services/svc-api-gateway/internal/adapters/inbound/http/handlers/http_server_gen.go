// Package handlers provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package handlers

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	PasetoAuthScopes = "PasetoAuth.Scopes"
)

// Defines values for AppliedFiltersState.
const (
	AppliedFiltersStateAvailable AppliedFiltersState = "available"
	AppliedFiltersStateInUse     AppliedFiltersState = "in-use"
	AppliedFiltersStateInactive  AppliedFiltersState = "inactive"
)

// Defines values for CacheDependencyCheckStatus.
const (
	CacheDependencyCheckStatusDegraded CacheDependencyCheckStatus = "degraded"
	CacheDependencyCheckStatusDown     CacheDependencyCheckStatus = "down"
	CacheDependencyCheckStatusUnknown  CacheDependencyCheckStatus = "unknown"
	CacheDependencyCheckStatusUp       CacheDependencyCheckStatus = "up"
)

// Defines values for CreateDeviceRequestState.
const (
	CreateDeviceRequestStateAvailable CreateDeviceRequestState = "available"
	CreateDeviceRequestStateInUse     CreateDeviceRequestState = "in-use"
	CreateDeviceRequestStateInactive  CreateDeviceRequestState = "inactive"
)

// Defines values for DependencyCheckStatus.
const (
	DependencyCheckStatusDegraded DependencyCheckStatus = "degraded"
	DependencyCheckStatusDown     DependencyCheckStatus = "down"
	DependencyCheckStatusUnknown  DependencyCheckStatus = "unknown"
	DependencyCheckStatusUp       DependencyCheckStatus = "up"
)

// Defines values for DeviceState.
const (
	DeviceStateAvailable DeviceState = "available"
	DeviceStateInUse     DeviceState = "in-use"
	DeviceStateInactive  DeviceState = "inactive"
)

// Defines values for DeviceListResponseDataState.
const (
	DeviceListResponseDataStateAvailable DeviceListResponseDataState = "available"
	DeviceListResponseDataStateInUse     DeviceListResponseDataState = "in-use"
	DeviceListResponseDataStateInactive  DeviceListResponseDataState = "inactive"
)

// Defines values for DeviceListResponseFiltersState.
const (
	DeviceListResponseFiltersStateAvailable DeviceListResponseFiltersState = "available"
	DeviceListResponseFiltersStateInUse     DeviceListResponseFiltersState = "in-use"
	DeviceListResponseFiltersStateInactive  DeviceListResponseFiltersState = "inactive"
)

// Defines values for DeviceResponseDataState.
const (
	DeviceResponseDataStateAvailable DeviceResponseDataState = "available"
	DeviceResponseDataStateInUse     DeviceResponseDataState = "in-use"
	DeviceResponseDataStateInactive  DeviceResponseDataState = "inactive"
)

// Defines values for HealthResponseChecksInfraCacheStatus.
const (
	HealthResponseChecksInfraCacheStatusDegraded HealthResponseChecksInfraCacheStatus = "degraded"
	HealthResponseChecksInfraCacheStatusDown     HealthResponseChecksInfraCacheStatus = "down"
	HealthResponseChecksInfraCacheStatusUnknown  HealthResponseChecksInfraCacheStatus = "unknown"
	HealthResponseChecksInfraCacheStatusUp       HealthResponseChecksInfraCacheStatus = "up"
)

// Defines values for HealthResponseChecksInfraStorageStatus.
const (
	HealthResponseChecksInfraStorageStatusDegraded HealthResponseChecksInfraStorageStatus = "degraded"
	HealthResponseChecksInfraStorageStatusDown     HealthResponseChecksInfraStorageStatus = "down"
	HealthResponseChecksInfraStorageStatusUnknown  HealthResponseChecksInfraStorageStatus = "unknown"
	HealthResponseChecksInfraStorageStatusUp       HealthResponseChecksInfraStorageStatus = "up"
)

// Defines values for HealthResponseChecksServicesDevicesStatus.
const (
	HealthResponseChecksServicesDevicesStatusDegraded HealthResponseChecksServicesDevicesStatus = "degraded"
	HealthResponseChecksServicesDevicesStatusDown     HealthResponseChecksServicesDevicesStatus = "down"
	HealthResponseChecksServicesDevicesStatusUnknown  HealthResponseChecksServicesDevicesStatus = "unknown"
	HealthResponseChecksServicesDevicesStatusUp       HealthResponseChecksServicesDevicesStatus = "up"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded    HealthResponseStatus = "degraded"
	HealthResponseStatusDown        HealthResponseStatus = "down"
	HealthResponseStatusMaintenance HealthResponseStatus = "maintenance"
	HealthResponseStatusOk          HealthResponseStatus = "ok"
)

// Defines values for LivenessResponseStatus.
const (
	LivenessResponseStatusDegraded    LivenessResponseStatus = "degraded"
	LivenessResponseStatusDown        LivenessResponseStatus = "down"
	LivenessResponseStatusMaintenance LivenessResponseStatus = "maintenance"
	LivenessResponseStatusOk          LivenessResponseStatus = "ok"
)

// Defines values for PatchDeviceRequestState.
const (
	PatchDeviceRequestStateAvailable PatchDeviceRequestState = "available"
	PatchDeviceRequestStateInUse     PatchDeviceRequestState = "in-use"
	PatchDeviceRequestStateInactive  PatchDeviceRequestState = "inactive"
)

// Defines values for ReadinessResponseChecksInfraCacheStatus.
const (
	ReadinessResponseChecksInfraCacheStatusDegraded ReadinessResponseChecksInfraCacheStatus = "degraded"
	ReadinessResponseChecksInfraCacheStatusDown     ReadinessResponseChecksInfraCacheStatus = "down"
	ReadinessResponseChecksInfraCacheStatusUnknown  ReadinessResponseChecksInfraCacheStatus = "unknown"
	ReadinessResponseChecksInfraCacheStatusUp       ReadinessResponseChecksInfraCacheStatus = "up"
)

// Defines values for ReadinessResponseChecksInfraStorageStatus.
const (
	ReadinessResponseChecksInfraStorageStatusDegraded ReadinessResponseChecksInfraStorageStatus = "degraded"
	ReadinessResponseChecksInfraStorageStatusDown     ReadinessResponseChecksInfraStorageStatus = "down"
	ReadinessResponseChecksInfraStorageStatusUnknown  ReadinessResponseChecksInfraStorageStatus = "unknown"
	ReadinessResponseChecksInfraStorageStatusUp       ReadinessResponseChecksInfraStorageStatus = "up"
)

// Defines values for ReadinessResponseChecksServicesDevicesStatus.
const (
	ReadinessResponseChecksServicesDevicesStatusDegraded ReadinessResponseChecksServicesDevicesStatus = "degraded"
	ReadinessResponseChecksServicesDevicesStatusDown     ReadinessResponseChecksServicesDevicesStatus = "down"
	ReadinessResponseChecksServicesDevicesStatusUnknown  ReadinessResponseChecksServicesDevicesStatus = "unknown"
	ReadinessResponseChecksServicesDevicesStatusUp       ReadinessResponseChecksServicesDevicesStatus = "up"
)

// Defines values for ReadinessResponseStatus.
const (
	Degraded    ReadinessResponseStatus = "degraded"
	Down        ReadinessResponseStatus = "down"
	Maintenance ReadinessResponseStatus = "maintenance"
	Ok          ReadinessResponseStatus = "ok"
)

// Defines values for UpdateDeviceRequestState.
const (
	UpdateDeviceRequestStateAvailable UpdateDeviceRequestState = "available"
	UpdateDeviceRequestStateInUse     UpdateDeviceRequestState = "in-use"
	UpdateDeviceRequestStateInactive  UpdateDeviceRequestState = "inactive"
)

// Defines values for ApiVersionHeader.
const (
	ApiVersionHeaderV1 ApiVersionHeader = "v1"
)

// Defines values for StateFilterParam.
const (
	StateFilterParamAvailable StateFilterParam = "available"
	StateFilterParamInUse     StateFilterParam = "in-use"
	StateFilterParamInactive  StateFilterParam = "inactive"
)

// Defines values for ListDevicesParamsState.
const (
	ListDevicesParamsStateAvailable ListDevicesParamsState = "available"
	ListDevicesParamsStateInUse     ListDevicesParamsState = "in-use"
	ListDevicesParamsStateInactive  ListDevicesParamsState = "inactive"
)

// Defines values for ListDevicesParamsAPIVersion.
const (
	ListDevicesParamsAPIVersionV1 ListDevicesParamsAPIVersion = "v1"
)

// Defines values for HeadDevicesParamsState.
const (
	HeadDevicesParamsStateAvailable HeadDevicesParamsState = "available"
	HeadDevicesParamsStateInUse     HeadDevicesParamsState = "in-use"
	HeadDevicesParamsStateInactive  HeadDevicesParamsState = "inactive"
)

// Defines values for HeadDevicesParamsAPIVersion.
const (
	HeadDevicesParamsAPIVersionV1 HeadDevicesParamsAPIVersion = "v1"
)

// Defines values for CreateDeviceParamsAPIVersion.
const (
	CreateDeviceParamsAPIVersionV1 CreateDeviceParamsAPIVersion = "v1"
)

// Defines values for CreateDeviceJSONBodyState.
const (
	CreateDeviceJSONBodyStateAvailable CreateDeviceJSONBodyState = "available"
	CreateDeviceJSONBodyStateInUse     CreateDeviceJSONBodyState = "in-use"
	CreateDeviceJSONBodyStateInactive  CreateDeviceJSONBodyState = "inactive"
)

// Defines values for DeleteDeviceParamsAPIVersion.
const (
	DeleteDeviceParamsAPIVersionV1 DeleteDeviceParamsAPIVersion = "v1"
)

// Defines values for GetDeviceParamsAPIVersion.
const (
	GetDeviceParamsAPIVersionV1 GetDeviceParamsAPIVersion = "v1"
)

// Defines values for HeadDeviceParamsAPIVersion.
const (
	HeadDeviceParamsAPIVersionV1 HeadDeviceParamsAPIVersion = "v1"
)

// Defines values for PatchDeviceParamsAPIVersion.
const (
	PatchDeviceParamsAPIVersionV1 PatchDeviceParamsAPIVersion = "v1"
)

// Defines values for PatchDeviceJSONBodyState.
const (
	PatchDeviceJSONBodyStateAvailable PatchDeviceJSONBodyState = "available"
	PatchDeviceJSONBodyStateInUse     PatchDeviceJSONBodyState = "in-use"
	PatchDeviceJSONBodyStateInactive  PatchDeviceJSONBodyState = "inactive"
)

// Defines values for UpdateDeviceParamsAPIVersion.
const (
	V1 UpdateDeviceParamsAPIVersion = "v1"
)

// Defines values for UpdateDeviceJSONBodyState.
const (
	UpdateDeviceJSONBodyStateAvailable UpdateDeviceJSONBodyState = "available"
	UpdateDeviceJSONBodyStateInUse     UpdateDeviceJSONBodyState = "in-use"
	UpdateDeviceJSONBodyStateInactive  UpdateDeviceJSONBodyState = "inactive"
)

// AppliedFilters Filters that were applied to this request
type AppliedFilters struct {
	// Brand Brand filter that was applied
	Brand *string `json:"brand"`

	// State State filter that was applied
	State *AppliedFiltersState `json:"state"`
}

// AppliedFiltersState State filter that was applied
type AppliedFiltersState string

// CacheDependencyCheck defines model for CacheDependencyCheck.
type CacheDependencyCheck struct {
	// Details Cache-specific details
	Details *struct {
		// PoolStats Connection pool statistics
		PoolStats *struct {
			// Hits Number of successful pool hits
			Hits *int `json:"hits,omitempty"`

			// IdleConnections Number of idle connections in the pool
			IdleConnections *int `json:"idleConnections,omitempty"`

			// Misses Number of pool misses
			Misses *int `json:"misses,omitempty"`

			// StaleConnections Number of stale connections removed from the pool
			StaleConnections *int `json:"staleConnections,omitempty"`

			// Timeouts Number of connection timeouts
			Timeouts *int `json:"timeouts,omitempty"`

			// TotalConnections Total number of connections in the pool
			TotalConnections *int `json:"totalConnections,omitempty"`

			// WaitCount Number of times a connection was waited for
			WaitCount *int `json:"waitCount,omitempty"`

			// WaitDurationNs Total time spent waiting for connections in nanoseconds
			WaitDurationNs *int `json:"waitDurationNs,omitempty"`
		} `json:"poolStats,omitempty"`

		// TotalKeys Total number of keys in the cache
		TotalKeys *int `json:"totalKeys,omitempty"`
	} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status CacheDependencyCheckStatus `json:"status"`
}

// CacheDependencyCheckStatus The status of the dependency
type CacheDependencyCheckStatus string

// CreateDeviceRequest Request body for creating a new device
type CreateDeviceRequest struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State Initial state of the device (defaults to "available" if not provided)
	State *CreateDeviceRequestState `json:"state,omitempty"`
}

// CreateDeviceRequestState Initial state of the device (defaults to "available" if not provided)
type CreateDeviceRequestState string

// DependencyCheck Status of a single dependency
type DependencyCheck struct {
	// Details Additional dependency-specific details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status DependencyCheckStatus `json:"status"`
}

// DependencyCheckStatus The status of the dependency
type DependencyCheckStatus string

// Device A device resource
type Device struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// CreatedAt Timestamp when the device was created (immutable)
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique identifier for the device (UUID v7)
	Id openapi_types.UUID `json:"id"`

	// Links HATEOAS links for device navigation
	Links *struct {
		// Self Link to this device resource
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`

	// UpdatedAt Timestamp when the device was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// DeviceState The current state of the device
type DeviceState string

// DeviceLinks HATEOAS links for device navigation
type DeviceLinks struct {
	// Self Link to this device resource
	Self *string `json:"self,omitempty"`
}

// DeviceListResponse Response containing a paginated list of devices
type DeviceListResponse struct {
	// Data List of devices
	Data []struct {
		// Brand The brand/manufacturer of the device
		Brand string `json:"brand"`

		// CreatedAt Timestamp when the device was created (immutable)
		CreatedAt time.Time `json:"createdAt"`

		// Id Unique identifier for the device (UUID v7)
		Id openapi_types.UUID `json:"id"`

		// Links HATEOAS links for device navigation
		Links *struct {
			// Self Link to this device resource
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Name The name of the device
		Name string `json:"name"`

		// State The current state of the device
		State DeviceListResponseDataState `json:"state"`

		// UpdatedAt Timestamp when the device was last updated
		UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	} `json:"data"`

	// Filters Filters that were applied to this request
	Filters *struct {
		// Brand Brand filter that was applied
		Brand *string `json:"brand"`

		// State State filter that was applied
		State *DeviceListResponseFiltersState `json:"state"`
	} `json:"filters,omitempty"`

	// Pagination Pagination metadata for list responses
	Pagination struct {
		// HasNext Whether there is a next page
		HasNext *bool `json:"hasNext,omitempty"`

		// HasPrevious Whether there is a previous page
		HasPrevious *bool `json:"hasPrevious,omitempty"`

		// Links HATEOAS links for pagination navigation
		Links *struct {
			// First Link to the first page
			First *string `json:"first,omitempty"`

			// Last Link to the last page
			Last *string `json:"last,omitempty"`

			// Next Link to the next page (null if on last page)
			Next *string `json:"next"`

			// Previous Link to the previous page (null if on first page)
			Previous *string `json:"previous"`

			// Self Link to the current page
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Page Current page number (1-indexed)
		Page int `json:"page"`

		// Size Number of items per page
		Size int `json:"size"`

		// TotalItems Total number of items across all pages
		TotalItems int `json:"totalItems"`

		// TotalPages Total number of pages
		TotalPages int `json:"totalPages"`
	} `json:"pagination"`
}

// DeviceListResponseDataState The current state of the device
type DeviceListResponseDataState string

// DeviceListResponseFiltersState State filter that was applied
type DeviceListResponseFiltersState string

// DeviceResponse Response containing a single device
type DeviceResponse struct {
	// Data A device resource
	Data struct {
		// Brand The brand/manufacturer of the device
		Brand string `json:"brand"`

		// CreatedAt Timestamp when the device was created (immutable)
		CreatedAt time.Time `json:"createdAt"`

		// Id Unique identifier for the device (UUID v7)
		Id openapi_types.UUID `json:"id"`

		// Links HATEOAS links for device navigation
		Links *struct {
			// Self Link to this device resource
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Name The name of the device
		Name string `json:"name"`

		// State The current state of the device
		State DeviceResponseDataState `json:"state"`

		// UpdatedAt Timestamp when the device was last updated
		UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	} `json:"data"`
}

// DeviceResponseDataState The current state of the device
type DeviceResponseDataState string

// ErrorDetail Detailed information about a specific error
type ErrorDetail struct {
	// Code Machine-readable error code for this specific error
	Code *string `json:"code,omitempty"`

	// Field The field that caused the error
	Field string `json:"field"`

	// Message Description of what is wrong with the field
	Message string `json:"message"`
}

// ErrorResponse Standard error response format
type ErrorResponse struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// HealthResponse Comprehensive health check response with system metrics
type HealthResponse struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *struct {
				// Details Cache-specific details
				Details *struct {
					// PoolStats Connection pool statistics
					PoolStats *struct {
						// Hits Number of successful pool hits
						Hits *int `json:"hits,omitempty"`

						// IdleConnections Number of idle connections in the pool
						IdleConnections *int `json:"idleConnections,omitempty"`

						// Misses Number of pool misses
						Misses *int `json:"misses,omitempty"`

						// StaleConnections Number of stale connections removed from the pool
						StaleConnections *int `json:"staleConnections,omitempty"`

						// Timeouts Number of connection timeouts
						Timeouts *int `json:"timeouts,omitempty"`

						// TotalConnections Total number of connections in the pool
						TotalConnections *int `json:"totalConnections,omitempty"`

						// WaitCount Number of times a connection was waited for
						WaitCount *int `json:"waitCount,omitempty"`

						// WaitDurationNs Total time spent waiting for connections in nanoseconds
						WaitDurationNs *int `json:"waitDurationNs,omitempty"`
					} `json:"poolStats,omitempty"`

					// TotalKeys Total number of keys in the cache
					TotalKeys *int `json:"totalKeys,omitempty"`
				} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksInfraCacheStatus `json:"status"`
			} `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksInfraStorageStatus `json:"status"`
			} `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksServicesDevicesStatus `json:"status"`
			} `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall health status of the service
	Status HealthResponseStatus `json:"status"`

	// System System resource information
	System *struct {
		// CpuCores Number of CPU cores available
		CpuCores *int `json:"cpuCores,omitempty"`

		// Goroutines Number of active goroutines
		Goroutines *int `json:"goroutines,omitempty"`

		// Memory Memory usage information
		Memory *struct {
			// AllocMb Current memory allocation in MB
			AllocMb *float32 `json:"allocMb,omitempty"`

			// GcCycles Number of completed GC cycles
			GcCycles *int `json:"gcCycles,omitempty"`

			// SysMb Total memory obtained from the OS in MB
			SysMb *float32 `json:"sysMb,omitempty"`

			// TotalAllocMb Total memory allocated since start in MB
			TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
		} `json:"memory,omitempty"`
	} `json:"system,omitempty"`

	// Timestamp Timestamp of the health check
	Timestamp time.Time `json:"timestamp"`

	// Uptime Service uptime information
	Uptime struct {
		// Duration Human-readable uptime duration
		Duration string `json:"duration"`

		// DurationSeconds Uptime in seconds
		DurationSeconds *int `json:"durationSeconds,omitempty"`

		// StartedAt Timestamp when the service started
		StartedAt time.Time `json:"startedAt"`
	} `json:"uptime"`

	// Version Version information about the service
	Version struct {
		// Api API version
		Api string `json:"api"`

		// Build Build version or commit hash
		Build string `json:"build"`

		// Go Go runtime version
		Go *string `json:"go,omitempty"`
	} `json:"version"`
}

// HealthResponseChecksInfraCacheStatus The status of the dependency
type HealthResponseChecksInfraCacheStatus string

// HealthResponseChecksInfraStorageStatus The status of the dependency
type HealthResponseChecksInfraStorageStatus string

// HealthResponseChecksServicesDevicesStatus The status of the dependency
type HealthResponseChecksServicesDevicesStatus string

// HealthResponseStatus The overall health status of the service
type HealthResponseStatus string

// LivenessResponse Liveness probe response
type LivenessResponse struct {
	// Status The liveness status of the service
	Status LivenessResponseStatus `json:"status"`

	// Timestamp Timestamp of the liveness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version string `json:"version"`
}

// LivenessResponseStatus The liveness status of the service
type LivenessResponseStatus string

// MemoryInfo Memory usage information
type MemoryInfo struct {
	// AllocMb Current memory allocation in MB
	AllocMb *float32 `json:"allocMb,omitempty"`

	// GcCycles Number of completed GC cycles
	GcCycles *int `json:"gcCycles,omitempty"`

	// SysMb Total memory obtained from the OS in MB
	SysMb *float32 `json:"sysMb,omitempty"`

	// TotalAllocMb Total memory allocated since start in MB
	TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
}

// Pagination Pagination metadata for list responses
type Pagination struct {
	// HasNext Whether there is a next page
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrevious Whether there is a previous page
	HasPrevious *bool `json:"hasPrevious,omitempty"`

	// Links HATEOAS links for pagination navigation
	Links *struct {
		// First Link to the first page
		First *string `json:"first,omitempty"`

		// Last Link to the last page
		Last *string `json:"last,omitempty"`

		// Next Link to the next page (null if on last page)
		Next *string `json:"next"`

		// Previous Link to the previous page (null if on first page)
		Previous *string `json:"previous"`

		// Self Link to the current page
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`

	// Page Current page number (1-indexed)
	Page int `json:"page"`

	// Size Number of items per page
	Size int `json:"size"`

	// TotalItems Total number of items across all pages
	TotalItems int `json:"totalItems"`

	// TotalPages Total number of pages
	TotalPages int `json:"totalPages"`
}

// PaginationLinks HATEOAS links for pagination navigation
type PaginationLinks struct {
	// First Link to the first page
	First *string `json:"first,omitempty"`

	// Last Link to the last page
	Last *string `json:"last,omitempty"`

	// Next Link to the next page (null if on last page)
	Next *string `json:"next"`

	// Previous Link to the previous page (null if on first page)
	Previous *string `json:"previous"`

	// Self Link to the current page
	Self *string `json:"self,omitempty"`
}

// PatchDeviceRequest Request body for partially updating a device (PATCH)
type PatchDeviceRequest struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The state of the device
	State *PatchDeviceRequestState `json:"state,omitempty"`
}

// PatchDeviceRequestState The state of the device
type PatchDeviceRequestState string

// PoolStats Connection pool statistics
type PoolStats struct {
	// Hits Number of successful pool hits
	Hits *int `json:"hits,omitempty"`

	// IdleConnections Number of idle connections in the pool
	IdleConnections *int `json:"idleConnections,omitempty"`

	// Misses Number of pool misses
	Misses *int `json:"misses,omitempty"`

	// StaleConnections Number of stale connections removed from the pool
	StaleConnections *int `json:"staleConnections,omitempty"`

	// Timeouts Number of connection timeouts
	Timeouts *int `json:"timeouts,omitempty"`

	// TotalConnections Total number of connections in the pool
	TotalConnections *int `json:"totalConnections,omitempty"`

	// WaitCount Number of times a connection was waited for
	WaitCount *int `json:"waitCount,omitempty"`

	// WaitDurationNs Total time spent waiting for connections in nanoseconds
	WaitDurationNs *int `json:"waitDurationNs,omitempty"`
}

// ReadinessResponse Readiness probe response with dependency status
type ReadinessResponse struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *struct {
				// Details Cache-specific details
				Details *struct {
					// PoolStats Connection pool statistics
					PoolStats *struct {
						// Hits Number of successful pool hits
						Hits *int `json:"hits,omitempty"`

						// IdleConnections Number of idle connections in the pool
						IdleConnections *int `json:"idleConnections,omitempty"`

						// Misses Number of pool misses
						Misses *int `json:"misses,omitempty"`

						// StaleConnections Number of stale connections removed from the pool
						StaleConnections *int `json:"staleConnections,omitempty"`

						// Timeouts Number of connection timeouts
						Timeouts *int `json:"timeouts,omitempty"`

						// TotalConnections Total number of connections in the pool
						TotalConnections *int `json:"totalConnections,omitempty"`

						// WaitCount Number of times a connection was waited for
						WaitCount *int `json:"waitCount,omitempty"`

						// WaitDurationNs Total time spent waiting for connections in nanoseconds
						WaitDurationNs *int `json:"waitDurationNs,omitempty"`
					} `json:"poolStats,omitempty"`

					// TotalKeys Total number of keys in the cache
					TotalKeys *int `json:"totalKeys,omitempty"`
				} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksInfraCacheStatus `json:"status"`
			} `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksInfraStorageStatus `json:"status"`
			} `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksServicesDevicesStatus `json:"status"`
			} `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall readiness status of the service
	Status ReadinessResponseStatus `json:"status"`

	// Timestamp Timestamp of the readiness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version (optional)
	Version *string `json:"version,omitempty"`
}

// ReadinessResponseChecksInfraCacheStatus The status of the dependency
type ReadinessResponseChecksInfraCacheStatus string

// ReadinessResponseChecksInfraStorageStatus The status of the dependency
type ReadinessResponseChecksInfraStorageStatus string

// ReadinessResponseChecksServicesDevicesStatus The status of the dependency
type ReadinessResponseChecksServicesDevicesStatus string

// ReadinessResponseStatus The overall readiness status of the service
type ReadinessResponseStatus string

// SystemInfo System resource information
type SystemInfo struct {
	// CpuCores Number of CPU cores available
	CpuCores *int `json:"cpuCores,omitempty"`

	// Goroutines Number of active goroutines
	Goroutines *int `json:"goroutines,omitempty"`

	// Memory Memory usage information
	Memory *struct {
		// AllocMb Current memory allocation in MB
		AllocMb *float32 `json:"allocMb,omitempty"`

		// GcCycles Number of completed GC cycles
		GcCycles *int `json:"gcCycles,omitempty"`

		// SysMb Total memory obtained from the OS in MB
		SysMb *float32 `json:"sysMb,omitempty"`

		// TotalAllocMb Total memory allocated since start in MB
		TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
	} `json:"memory,omitempty"`
}

// UpdateDeviceRequest Request body for fully updating a device (PUT)
type UpdateDeviceRequest struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The state of the device
	State UpdateDeviceRequestState `json:"state"`
}

// UpdateDeviceRequestState The state of the device
type UpdateDeviceRequestState string

// UptimeInfo Service uptime information
type UptimeInfo struct {
	// Duration Human-readable uptime duration
	Duration string `json:"duration"`

	// DurationSeconds Uptime in seconds
	DurationSeconds *int `json:"durationSeconds,omitempty"`

	// StartedAt Timestamp when the service started
	StartedAt time.Time `json:"startedAt"`
}

// VersionInfo Version information about the service
type VersionInfo struct {
	// Api API version
	Api string `json:"api"`

	// Build Build version or commit hash
	Build string `json:"build"`

	// Go Go runtime version
	Go *string `json:"go,omitempty"`
}

// AcceptEncodingHeader defines model for AcceptEncodingHeader.
type AcceptEncodingHeader = string

// AcceptHeader defines model for AcceptHeader.
type AcceptHeader = string

// ApiVersionHeader defines model for ApiVersionHeader.
type ApiVersionHeader string

// AuthorizationHeader defines model for AuthorizationHeader.
type AuthorizationHeader = string

// BrandFilterParam defines model for BrandFilterParam.
type BrandFilterParam = string

// CorrelationIdHeader defines model for CorrelationIdHeader.
type CorrelationIdHeader = openapi_types.UUID

// DeviceIdParam defines model for DeviceIdParam.
type DeviceIdParam = openapi_types.UUID

// FieldsParam defines model for FieldsParam.
type FieldsParam = string

// IdempotencyKeyHeader defines model for IdempotencyKeyHeader.
type IdempotencyKeyHeader = openapi_types.UUID

// IfMatchHeader defines model for IfMatchHeader.
type IfMatchHeader = string

// IfNoneMatchHeader defines model for IfNoneMatchHeader.
type IfNoneMatchHeader = string

// PageParam defines model for PageParam.
type PageParam = int

// RequestIdHeader defines model for RequestIdHeader.
type RequestIdHeader = openapi_types.UUID

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = string

// StateFilterParam The current state of the device
type StateFilterParam string

// TraceparentHeader defines model for TraceparentHeader.
type TraceparentHeader = string

// TracestateHeader defines model for TracestateHeader.
type TracestateHeader = string

// BadRequest Standard error response format
type BadRequest struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// Conflict Standard error response format
type Conflict struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// NotAcceptable Standard error response format
type NotAcceptable struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// NotFound Standard error response format
type NotFound struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// PreconditionFailed Standard error response format
type PreconditionFailed struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// RateLimit Standard error response format
type RateLimit struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ServerError Standard error response format
type ServerError struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// Unauthorized Standard error response format
type Unauthorized struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// UnprocessableEntity Standard error response format
type UnprocessableEntity struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter devices by brand (case-insensitive, partial match)
	Brand *string `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter devices by state
	State *ListDevicesParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Sort Field to sort results by. Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ListDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// ListDevicesParamsState defines parameters for ListDevices.
type ListDevicesParamsState string

// ListDevicesParamsAPIVersion defines parameters for ListDevices.
type ListDevicesParamsAPIVersion string

// HeadDevicesParams defines parameters for HeadDevices.
type HeadDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter devices by brand (case-insensitive, partial match)
	Brand *string `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter devices by state
	State *HeadDevicesParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Sort Field to sort results by. Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadDevicesParamsState defines parameters for HeadDevices.
type HeadDevicesParamsState string

// HeadDevicesParamsAPIVersion defines parameters for HeadDevices.
type HeadDevicesParamsAPIVersion string

// CreateDeviceJSONBody defines parameters for CreateDevice.
type CreateDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State Initial state of the device (defaults to "available" if not provided)
	State *CreateDeviceJSONBodyState `json:"state,omitempty"`
}

// CreateDeviceParams defines parameters for CreateDevice.
type CreateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *CreateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IdempotencyKey Unique key to ensure idempotent POST requests.
	// If the same key is sent again within the TTL window (24 hours),
	// the server returns the cached response instead of creating a duplicate.
	//
	// **Requirements:**
	// - Must be a valid UUID v7
	// - Must be unique per logical operation
	// - Cached for 24 hours
	IdempotencyKey openapi_types.UUID `json:"Idempotency-Key"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// CreateDeviceParamsAPIVersion defines parameters for CreateDevice.
type CreateDeviceParamsAPIVersion string

// CreateDeviceJSONBodyState defines parameters for CreateDevice.
type CreateDeviceJSONBodyState string

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *DeleteDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`
}

// DeleteDeviceParamsAPIVersion defines parameters for DeleteDevice.
type DeleteDeviceParamsAPIVersion string

// GetDeviceParams defines parameters for GetDevice.
type GetDeviceParams struct {
	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *GetDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// GetDeviceParamsAPIVersion defines parameters for GetDevice.
type GetDeviceParamsAPIVersion string

// HeadDeviceParams defines parameters for HeadDevice.
type HeadDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadDeviceParamsAPIVersion defines parameters for HeadDevice.
type HeadDeviceParamsAPIVersion string

// PatchDeviceJSONBody defines parameters for PatchDevice.
type PatchDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The state of the device
	State *PatchDeviceJSONBodyState `json:"state,omitempty"`
}

// PatchDeviceParams defines parameters for PatchDevice.
type PatchDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *PatchDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// PatchDeviceParamsAPIVersion defines parameters for PatchDevice.
type PatchDeviceParamsAPIVersion string

// PatchDeviceJSONBodyState defines parameters for PatchDevice.
type PatchDeviceJSONBodyState string

// UpdateDeviceJSONBody defines parameters for UpdateDevice.
type UpdateDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The state of the device
	State UpdateDeviceJSONBodyState `json:"state"`
}

// UpdateDeviceParams defines parameters for UpdateDevice.
type UpdateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *UpdateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// UpdateDeviceParamsAPIVersion defines parameters for UpdateDevice.
type UpdateDeviceParamsAPIVersion string

// UpdateDeviceJSONBodyState defines parameters for UpdateDevice.
type UpdateDeviceJSONBodyState string

// CreateDeviceJSONRequestBody defines body for CreateDevice for application/json ContentType.
type CreateDeviceJSONRequestBody CreateDeviceJSONBody

// PatchDeviceJSONRequestBody defines body for PatchDevice for application/json ContentType.
type PatchDeviceJSONRequestBody PatchDeviceJSONBody

// UpdateDeviceJSONRequestBody defines body for UpdateDevice for application/json ContentType.
type UpdateDeviceJSONRequestBody UpdateDeviceJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all devices
	// (GET /devices)
	ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams)
	// Get devices collection metadata
	// (HEAD /devices)
	HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams)
	// Get allowed methods for devices collection
	// (OPTIONS /devices)
	OptionsDevices(w http.ResponseWriter, r *http.Request)
	// Create a new device
	// (POST /devices)
	CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams)
	// Delete a device
	// (DELETE /devices/{deviceId})
	DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params DeleteDeviceParams)
	// Get a device by ID
	// (GET /devices/{deviceId})
	GetDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params GetDeviceParams)
	// Get device metadata
	// (HEAD /devices/{deviceId})
	HeadDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params HeadDeviceParams)
	// Get allowed methods for device resource
	// (OPTIONS /devices/{deviceId})
	OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID)
	// Partially update a device
	// (PATCH /devices/{deviceId})
	PatchDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params PatchDeviceParams)
	// Fully update a device
	// (PUT /devices/{deviceId})
	UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params UpdateDeviceParams)
	// Health check
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// Liveness probe
	// (GET /liveness)
	LivenessCheck(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /readiness)
	ReadinessCheck(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List all devices
// (GET /devices)
func (_ Unimplemented) ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get devices collection metadata
// (HEAD /devices)
func (_ Unimplemented) HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for devices collection
// (OPTIONS /devices)
func (_ Unimplemented) OptionsDevices(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new device
// (POST /devices)
func (_ Unimplemented) CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a device
// (DELETE /devices/{deviceId})
func (_ Unimplemented) DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params DeleteDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a device by ID
// (GET /devices/{deviceId})
func (_ Unimplemented) GetDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params GetDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get device metadata
// (HEAD /devices/{deviceId})
func (_ Unimplemented) HeadDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params HeadDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for device resource
// (OPTIONS /devices/{deviceId})
func (_ Unimplemented) OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Partially update a device
// (PATCH /devices/{deviceId})
func (_ Unimplemented) PatchDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params PatchDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fully update a device
// (PUT /devices/{deviceId})
func (_ Unimplemented) UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params UpdateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /liveness)
func (_ Unimplemented) LivenessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /readiness)
func (_ Unimplemented) ReadinessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", true, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ListDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevices operation middleware
func (siw *ServerInterfaceWrapper) HeadDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", true, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevices operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevices(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevices(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateDevice operation middleware
func (siw *ServerInterfaceWrapper) CreateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion CreateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Required header parameter "Idempotency-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Idempotency-Key")]; found {
		var IdempotencyKey openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Idempotency-Key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Idempotency-Key", valueList[0], &IdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Idempotency-Key", Err: err})
			return
		}

		params.IdempotencyKey = IdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter Idempotency-Key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Idempotency-Key", Err: err})
		return
	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDevice(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDevice operation middleware
func (siw *ServerInterfaceWrapper) DeleteDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion DeleteDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDevice operation middleware
func (siw *ServerInterfaceWrapper) GetDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDeviceParams

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion GetDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevice operation middleware
func (siw *ServerInterfaceWrapper) HeadDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevice operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevice(w, r, deviceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchDevice operation middleware
func (siw *ServerInterfaceWrapper) PatchDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion PatchDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateDevice operation middleware
func (siw *ServerInterfaceWrapper) UpdateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion UpdateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LivenessCheck operation middleware
func (siw *ServerInterfaceWrapper) LivenessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LivenessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadinessCheck operation middleware
func (siw *ServerInterfaceWrapper) ReadinessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadinessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices", wrapper.ListDevices)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices", wrapper.HeadDevices)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices", wrapper.OptionsDevices)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/devices", wrapper.CreateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/devices/{deviceId}", wrapper.DeleteDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices/{deviceId}", wrapper.GetDevice)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices/{deviceId}", wrapper.HeadDevice)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices/{deviceId}", wrapper.OptionsDevice)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/devices/{deviceId}", wrapper.PatchDevice)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/devices/{deviceId}", wrapper.UpdateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/liveness", wrapper.LivenessCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/readiness", wrapper.ReadinessCheck)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
