// Package handlers provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package handlers

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	PasetoAuthScopes = "PasetoAuth.Scopes"
)

// Defines values for CacheDependencyCheckStatus.
const (
	CacheDependencyCheckStatusDegraded CacheDependencyCheckStatus = "degraded"
	CacheDependencyCheckStatusDown     CacheDependencyCheckStatus = "down"
	CacheDependencyCheckStatusUnknown  CacheDependencyCheckStatus = "unknown"
	CacheDependencyCheckStatusUp       CacheDependencyCheckStatus = "up"
)

// Defines values for CreateDeviceRequestState.
const (
	CreateDeviceRequestStateAvailable CreateDeviceRequestState = "available"
	CreateDeviceRequestStateInUse     CreateDeviceRequestState = "in-use"
	CreateDeviceRequestStateInactive  CreateDeviceRequestState = "inactive"
)

// Defines values for DependencyCheckStatus.
const (
	DependencyCheckStatusDegraded DependencyCheckStatus = "degraded"
	DependencyCheckStatusDown     DependencyCheckStatus = "down"
	DependencyCheckStatusUnknown  DependencyCheckStatus = "unknown"
	DependencyCheckStatusUp       DependencyCheckStatus = "up"
)

// Defines values for DeviceState.
const (
	DeviceStateAvailable DeviceState = "available"
	DeviceStateInUse     DeviceState = "in-use"
	DeviceStateInactive  DeviceState = "inactive"
)

// Defines values for DeviceListResponseDataState.
const (
	DeviceListResponseDataStateAvailable DeviceListResponseDataState = "available"
	DeviceListResponseDataStateInUse     DeviceListResponseDataState = "in-use"
	DeviceListResponseDataStateInactive  DeviceListResponseDataState = "inactive"
)

// Defines values for DeviceListResponseMetaApiVersion.
const (
	DeviceListResponseMetaApiVersionV1 DeviceListResponseMetaApiVersion = "v1"
)

// Defines values for DeviceResponseDataState.
const (
	DeviceResponseDataStateAvailable DeviceResponseDataState = "available"
	DeviceResponseDataStateInUse     DeviceResponseDataState = "in-use"
	DeviceResponseDataStateInactive  DeviceResponseDataState = "inactive"
)

// Defines values for DeviceResponseMetaApiVersion.
const (
	DeviceResponseMetaApiVersionV1 DeviceResponseMetaApiVersion = "v1"
)

// Defines values for HealthResponseChecksInfraCacheStatus.
const (
	HealthResponseChecksInfraCacheStatusDegraded HealthResponseChecksInfraCacheStatus = "degraded"
	HealthResponseChecksInfraCacheStatusDown     HealthResponseChecksInfraCacheStatus = "down"
	HealthResponseChecksInfraCacheStatusUnknown  HealthResponseChecksInfraCacheStatus = "unknown"
	HealthResponseChecksInfraCacheStatusUp       HealthResponseChecksInfraCacheStatus = "up"
)

// Defines values for HealthResponseChecksInfraStorageStatus.
const (
	HealthResponseChecksInfraStorageStatusDegraded HealthResponseChecksInfraStorageStatus = "degraded"
	HealthResponseChecksInfraStorageStatusDown     HealthResponseChecksInfraStorageStatus = "down"
	HealthResponseChecksInfraStorageStatusUnknown  HealthResponseChecksInfraStorageStatus = "unknown"
	HealthResponseChecksInfraStorageStatusUp       HealthResponseChecksInfraStorageStatus = "up"
)

// Defines values for HealthResponseChecksServicesDevicesStatus.
const (
	HealthResponseChecksServicesDevicesStatusDegraded HealthResponseChecksServicesDevicesStatus = "degraded"
	HealthResponseChecksServicesDevicesStatusDown     HealthResponseChecksServicesDevicesStatus = "down"
	HealthResponseChecksServicesDevicesStatusUnknown  HealthResponseChecksServicesDevicesStatus = "unknown"
	HealthResponseChecksServicesDevicesStatusUp       HealthResponseChecksServicesDevicesStatus = "up"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded    HealthResponseStatus = "degraded"
	HealthResponseStatusDown        HealthResponseStatus = "down"
	HealthResponseStatusMaintenance HealthResponseStatus = "maintenance"
	HealthResponseStatusOk          HealthResponseStatus = "ok"
)

// Defines values for LivenessResponseStatus.
const (
	LivenessResponseStatusDegraded    LivenessResponseStatus = "degraded"
	LivenessResponseStatusDown        LivenessResponseStatus = "down"
	LivenessResponseStatusMaintenance LivenessResponseStatus = "maintenance"
	LivenessResponseStatusOk          LivenessResponseStatus = "ok"
)

// Defines values for MetaApiVersion.
const (
	MetaApiVersionV1 MetaApiVersion = "v1"
)

// Defines values for PatchDeviceRequestState.
const (
	PatchDeviceRequestStateAvailable PatchDeviceRequestState = "available"
	PatchDeviceRequestStateInUse     PatchDeviceRequestState = "in-use"
	PatchDeviceRequestStateInactive  PatchDeviceRequestState = "inactive"
)

// Defines values for ReadinessResponseChecksInfraCacheStatus.
const (
	ReadinessResponseChecksInfraCacheStatusDegraded ReadinessResponseChecksInfraCacheStatus = "degraded"
	ReadinessResponseChecksInfraCacheStatusDown     ReadinessResponseChecksInfraCacheStatus = "down"
	ReadinessResponseChecksInfraCacheStatusUnknown  ReadinessResponseChecksInfraCacheStatus = "unknown"
	ReadinessResponseChecksInfraCacheStatusUp       ReadinessResponseChecksInfraCacheStatus = "up"
)

// Defines values for ReadinessResponseChecksInfraStorageStatus.
const (
	ReadinessResponseChecksInfraStorageStatusDegraded ReadinessResponseChecksInfraStorageStatus = "degraded"
	ReadinessResponseChecksInfraStorageStatusDown     ReadinessResponseChecksInfraStorageStatus = "down"
	ReadinessResponseChecksInfraStorageStatusUnknown  ReadinessResponseChecksInfraStorageStatus = "unknown"
	ReadinessResponseChecksInfraStorageStatusUp       ReadinessResponseChecksInfraStorageStatus = "up"
)

// Defines values for ReadinessResponseChecksServicesDevicesStatus.
const (
	ReadinessResponseChecksServicesDevicesStatusDegraded ReadinessResponseChecksServicesDevicesStatus = "degraded"
	ReadinessResponseChecksServicesDevicesStatusDown     ReadinessResponseChecksServicesDevicesStatus = "down"
	ReadinessResponseChecksServicesDevicesStatusUnknown  ReadinessResponseChecksServicesDevicesStatus = "unknown"
	ReadinessResponseChecksServicesDevicesStatusUp       ReadinessResponseChecksServicesDevicesStatus = "up"
)

// Defines values for ReadinessResponseStatus.
const (
	Degraded    ReadinessResponseStatus = "degraded"
	Down        ReadinessResponseStatus = "down"
	Maintenance ReadinessResponseStatus = "maintenance"
	Ok          ReadinessResponseStatus = "ok"
)

// Defines values for UpdateDeviceRequestState.
const (
	UpdateDeviceRequestStateAvailable UpdateDeviceRequestState = "available"
	UpdateDeviceRequestStateInUse     UpdateDeviceRequestState = "in-use"
	UpdateDeviceRequestStateInactive  UpdateDeviceRequestState = "inactive"
)

// Defines values for ApiVersionHeader.
const (
	ApiVersionHeaderV1 ApiVersionHeader = "v1"
)

// Defines values for ListDevicesParamsState.
const (
	ListDevicesParamsStateAvailable ListDevicesParamsState = "available"
	ListDevicesParamsStateInUse     ListDevicesParamsState = "in-use"
	ListDevicesParamsStateInactive  ListDevicesParamsState = "inactive"
)

// Defines values for ListDevicesParamsAPIVersion.
const (
	ListDevicesParamsAPIVersionV1 ListDevicesParamsAPIVersion = "v1"
)

// Defines values for HeadDevicesParamsState.
const (
	HeadDevicesParamsStateAvailable HeadDevicesParamsState = "available"
	HeadDevicesParamsStateInUse     HeadDevicesParamsState = "in-use"
	HeadDevicesParamsStateInactive  HeadDevicesParamsState = "inactive"
)

// Defines values for HeadDevicesParamsAPIVersion.
const (
	HeadDevicesParamsAPIVersionV1 HeadDevicesParamsAPIVersion = "v1"
)

// Defines values for CreateDeviceParamsAPIVersion.
const (
	CreateDeviceParamsAPIVersionV1 CreateDeviceParamsAPIVersion = "v1"
)

// Defines values for CreateDeviceJSONBodyState.
const (
	CreateDeviceJSONBodyStateAvailable CreateDeviceJSONBodyState = "available"
	CreateDeviceJSONBodyStateInUse     CreateDeviceJSONBodyState = "in-use"
	CreateDeviceJSONBodyStateInactive  CreateDeviceJSONBodyState = "inactive"
)

// Defines values for DeleteDeviceParamsAPIVersion.
const (
	DeleteDeviceParamsAPIVersionV1 DeleteDeviceParamsAPIVersion = "v1"
)

// Defines values for GetDeviceParamsAPIVersion.
const (
	GetDeviceParamsAPIVersionV1 GetDeviceParamsAPIVersion = "v1"
)

// Defines values for HeadDeviceParamsAPIVersion.
const (
	HeadDeviceParamsAPIVersionV1 HeadDeviceParamsAPIVersion = "v1"
)

// Defines values for PatchDeviceParamsAPIVersion.
const (
	PatchDeviceParamsAPIVersionV1 PatchDeviceParamsAPIVersion = "v1"
)

// Defines values for PatchDeviceJSONBodyState.
const (
	PatchDeviceJSONBodyStateAvailable PatchDeviceJSONBodyState = "available"
	PatchDeviceJSONBodyStateInUse     PatchDeviceJSONBodyState = "in-use"
	PatchDeviceJSONBodyStateInactive  PatchDeviceJSONBodyState = "inactive"
)

// Defines values for UpdateDeviceParamsAPIVersion.
const (
	UpdateDeviceParamsAPIVersionV1 UpdateDeviceParamsAPIVersion = "v1"
)

// Defines values for UpdateDeviceJSONBodyState.
const (
	Available UpdateDeviceJSONBodyState = "available"
	InUse     UpdateDeviceJSONBodyState = "in-use"
	Inactive  UpdateDeviceJSONBodyState = "inactive"
)

// CacheDependencyCheck defines model for CacheDependencyCheck.
type CacheDependencyCheck struct {
	// Details Cache-specific details
	Details *struct {
		// PoolStats Connection pool statistics
		PoolStats *struct {
			// Hits Number of successful pool hits
			Hits *int `json:"hits,omitempty"`

			// IdleConnections Number of idle connections in the pool
			IdleConnections *int `json:"idleConnections,omitempty"`

			// Misses Number of pool misses
			Misses *int `json:"misses,omitempty"`

			// StaleConnections Number of stale connections removed from the pool
			StaleConnections *int `json:"staleConnections,omitempty"`

			// Timeouts Number of connection timeouts
			Timeouts *int `json:"timeouts,omitempty"`

			// TotalConnections Total number of connections in the pool
			TotalConnections *int `json:"totalConnections,omitempty"`

			// WaitCount Number of times a connection was waited for
			WaitCount *int `json:"waitCount,omitempty"`

			// WaitDurationNs Total time spent waiting for connections in nanoseconds
			WaitDurationNs *int `json:"waitDurationNs,omitempty"`
		} `json:"poolStats,omitempty"`

		// TotalKeys Total number of keys in the cache
		TotalKeys *int `json:"totalKeys,omitempty"`
	} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status CacheDependencyCheckStatus `json:"status"`
}

// CacheDependencyCheckStatus The status of the dependency
type CacheDependencyCheckStatus string

// CreateDeviceRequest Request body for creating a new device
type CreateDeviceRequest struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State Initial state of the device (defaults to "available" if not provided)
	State *CreateDeviceRequestState `json:"state,omitempty"`
}

// CreateDeviceRequestState Initial state of the device (defaults to "available" if not provided)
type CreateDeviceRequestState string

// DependencyCheck Status of a single dependency
type DependencyCheck struct {
	// Details Additional dependency-specific details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status DependencyCheckStatus `json:"status"`
}

// DependencyCheckStatus The status of the dependency
type DependencyCheckStatus string

// Device A device resource
type Device struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// CreatedAt Timestamp when the device was created (immutable)
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique identifier for the device (UUID v7)
	Id openapi_types.UUID `json:"id"`

	// Links HATEOAS links for device navigation
	Links *struct {
		// Self Link to this device resource
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`

	// UpdatedAt Timestamp when the device was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// DeviceState The current state of the device
type DeviceState string

// DeviceLinks HATEOAS links for device navigation
type DeviceLinks struct {
	// Self Link to this device resource
	Self *string `json:"self,omitempty"`
}

// DeviceListResponse Response envelope containing a paginated list of devices with metadata
type DeviceListResponse struct {
	// Data List of devices
	Data []struct {
		// Brand The brand/manufacturer of the device
		Brand string `json:"brand"`

		// CreatedAt Timestamp when the device was created (immutable)
		CreatedAt time.Time `json:"createdAt"`

		// Id Unique identifier for the device (UUID v7)
		Id openapi_types.UUID `json:"id"`

		// Links HATEOAS links for device navigation
		Links *struct {
			// Self Link to this device resource
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Name The name of the device
		Name string `json:"name"`

		// State The current state of the device
		State DeviceListResponseDataState `json:"state"`

		// UpdatedAt Timestamp when the device was last updated
		UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	} `json:"data"`

	// Meta Response metadata containing tracing information and API versioning.
	// All successful responses include this field to support observability and debugging.
	Meta struct {
		// ApiVersion API version used to process this request
		ApiVersion DeviceListResponseMetaApiVersion `json:"apiVersion"`

		// RequestId Unique identifier for this specific request.
		// Matches the `Request-Id` response header.
		// Use this for correlating logs and debugging.
		RequestId openapi_types.UUID `json:"requestId"`

		// TraceId W3C Trace Context trace ID extracted from the traceparent header.
		// Present only when distributed tracing is enabled.
		// Use this to trace requests across multiple services.
		TraceId *string `json:"traceId,omitempty"`
	} `json:"meta"`

	// Pagination Pagination metadata for list responses
	Pagination struct {
		// HasNext Whether there is a next page
		HasNext *bool `json:"hasNext,omitempty"`

		// HasPrevious Whether there is a previous page
		HasPrevious *bool `json:"hasPrevious,omitempty"`

		// Links HATEOAS links for pagination navigation
		Links *struct {
			// First Link to the first page
			First *string `json:"first,omitempty"`

			// Last Link to the last page
			Last *string `json:"last,omitempty"`

			// Next Link to the next page (null if on last page)
			Next *string `json:"next"`

			// Previous Link to the previous page (null if on first page)
			Previous *string `json:"previous"`

			// Self Link to the current page
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// NextCursor Opaque cursor for fetching the next page using keyset pagination.
		// Only present when hasNext is true.
		NextCursor *string `json:"nextCursor,omitempty"`

		// Page Current page number (1-indexed)
		Page int `json:"page"`

		// PreviousCursor Opaque cursor for fetching the previous page using keyset pagination.
		// Only present when hasPrevious is true.
		PreviousCursor *string `json:"previousCursor,omitempty"`

		// Size Number of items per page
		Size int `json:"size"`

		// TotalItems Total number of items across all pages
		TotalItems int `json:"totalItems"`

		// TotalPages Total number of pages
		TotalPages int `json:"totalPages"`
	} `json:"pagination"`
}

// DeviceListResponseDataState The current state of the device
type DeviceListResponseDataState string

// DeviceListResponseMetaApiVersion API version used to process this request
type DeviceListResponseMetaApiVersion string

// DeviceResponse Response envelope containing a single device with metadata
type DeviceResponse struct {
	// Data A device resource
	Data struct {
		// Brand The brand/manufacturer of the device
		Brand string `json:"brand"`

		// CreatedAt Timestamp when the device was created (immutable)
		CreatedAt time.Time `json:"createdAt"`

		// Id Unique identifier for the device (UUID v7)
		Id openapi_types.UUID `json:"id"`

		// Links HATEOAS links for device navigation
		Links *struct {
			// Self Link to this device resource
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Name The name of the device
		Name string `json:"name"`

		// State The current state of the device
		State DeviceResponseDataState `json:"state"`

		// UpdatedAt Timestamp when the device was last updated
		UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	} `json:"data"`

	// Meta Response metadata containing tracing information and API versioning.
	// All successful responses include this field to support observability and debugging.
	Meta struct {
		// ApiVersion API version used to process this request
		ApiVersion DeviceResponseMetaApiVersion `json:"apiVersion"`

		// RequestId Unique identifier for this specific request.
		// Matches the `Request-Id` response header.
		// Use this for correlating logs and debugging.
		RequestId openapi_types.UUID `json:"requestId"`

		// TraceId W3C Trace Context trace ID extracted from the traceparent header.
		// Present only when distributed tracing is enabled.
		// Use this to trace requests across multiple services.
		TraceId *string `json:"traceId,omitempty"`
	} `json:"meta"`
}

// DeviceResponseDataState The current state of the device
type DeviceResponseDataState string

// DeviceResponseMetaApiVersion API version used to process this request
type DeviceResponseMetaApiVersion string

// ErrorDetail Detailed information about a specific error
type ErrorDetail struct {
	// Code Machine-readable error code for this specific error
	Code *string `json:"code,omitempty"`

	// Field The field that caused the error
	Field string `json:"field"`

	// Message Description of what is wrong with the field
	Message string `json:"message"`
}

// ErrorResponse Standard error response format
type ErrorResponse struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// HealthResponse Comprehensive health check response with system metrics
type HealthResponse struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *struct {
				// Details Cache-specific details
				Details *struct {
					// PoolStats Connection pool statistics
					PoolStats *struct {
						// Hits Number of successful pool hits
						Hits *int `json:"hits,omitempty"`

						// IdleConnections Number of idle connections in the pool
						IdleConnections *int `json:"idleConnections,omitempty"`

						// Misses Number of pool misses
						Misses *int `json:"misses,omitempty"`

						// StaleConnections Number of stale connections removed from the pool
						StaleConnections *int `json:"staleConnections,omitempty"`

						// Timeouts Number of connection timeouts
						Timeouts *int `json:"timeouts,omitempty"`

						// TotalConnections Total number of connections in the pool
						TotalConnections *int `json:"totalConnections,omitempty"`

						// WaitCount Number of times a connection was waited for
						WaitCount *int `json:"waitCount,omitempty"`

						// WaitDurationNs Total time spent waiting for connections in nanoseconds
						WaitDurationNs *int `json:"waitDurationNs,omitempty"`
					} `json:"poolStats,omitempty"`

					// TotalKeys Total number of keys in the cache
					TotalKeys *int `json:"totalKeys,omitempty"`
				} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksInfraCacheStatus `json:"status"`
			} `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksInfraStorageStatus `json:"status"`
			} `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksServicesDevicesStatus `json:"status"`
			} `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall health status of the service
	Status HealthResponseStatus `json:"status"`

	// System System resource information
	System *struct {
		// CpuCores Number of CPU cores available
		CpuCores *int `json:"cpuCores,omitempty"`

		// Goroutines Number of active goroutines
		Goroutines *int `json:"goroutines,omitempty"`

		// Memory Memory usage information
		Memory *struct {
			// AllocMb Current memory allocation in MB
			AllocMb *float32 `json:"allocMb,omitempty"`

			// GcCycles Number of completed GC cycles
			GcCycles *int `json:"gcCycles,omitempty"`

			// SysMb Total memory obtained from the OS in MB
			SysMb *float32 `json:"sysMb,omitempty"`

			// TotalAllocMb Total memory allocated since start in MB
			TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
		} `json:"memory,omitempty"`
	} `json:"system,omitempty"`

	// Timestamp Timestamp of the health check
	Timestamp time.Time `json:"timestamp"`

	// Uptime Service uptime information
	Uptime struct {
		// Duration Human-readable uptime duration
		Duration string `json:"duration"`

		// DurationSeconds Uptime in seconds
		DurationSeconds *int `json:"durationSeconds,omitempty"`

		// StartedAt Timestamp when the service started
		StartedAt time.Time `json:"startedAt"`
	} `json:"uptime"`

	// Version Version information about the service
	Version struct {
		// Api API version
		Api string `json:"api"`

		// Build Build version or commit hash
		Build string `json:"build"`

		// Go Go runtime version
		Go *string `json:"go,omitempty"`
	} `json:"version"`
}

// HealthResponseChecksInfraCacheStatus The status of the dependency
type HealthResponseChecksInfraCacheStatus string

// HealthResponseChecksInfraStorageStatus The status of the dependency
type HealthResponseChecksInfraStorageStatus string

// HealthResponseChecksServicesDevicesStatus The status of the dependency
type HealthResponseChecksServicesDevicesStatus string

// HealthResponseStatus The overall health status of the service
type HealthResponseStatus string

// LivenessResponse Liveness probe response
type LivenessResponse struct {
	// Status The liveness status of the service
	Status LivenessResponseStatus `json:"status"`

	// Timestamp Timestamp of the liveness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version string `json:"version"`
}

// LivenessResponseStatus The liveness status of the service
type LivenessResponseStatus string

// MemoryInfo Memory usage information
type MemoryInfo struct {
	// AllocMb Current memory allocation in MB
	AllocMb *float32 `json:"allocMb,omitempty"`

	// GcCycles Number of completed GC cycles
	GcCycles *int `json:"gcCycles,omitempty"`

	// SysMb Total memory obtained from the OS in MB
	SysMb *float32 `json:"sysMb,omitempty"`

	// TotalAllocMb Total memory allocated since start in MB
	TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
}

// Meta Response metadata containing tracing information and API versioning.
// All successful responses include this field to support observability and debugging.
type Meta struct {
	// ApiVersion API version used to process this request
	ApiVersion MetaApiVersion `json:"apiVersion"`

	// RequestId Unique identifier for this specific request.
	// Matches the `Request-Id` response header.
	// Use this for correlating logs and debugging.
	RequestId openapi_types.UUID `json:"requestId"`

	// TraceId W3C Trace Context trace ID extracted from the traceparent header.
	// Present only when distributed tracing is enabled.
	// Use this to trace requests across multiple services.
	TraceId *string `json:"traceId,omitempty"`
}

// MetaApiVersion API version used to process this request
type MetaApiVersion string

// Pagination Pagination metadata for list responses
type Pagination struct {
	// HasNext Whether there is a next page
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrevious Whether there is a previous page
	HasPrevious *bool `json:"hasPrevious,omitempty"`

	// Links HATEOAS links for pagination navigation
	Links *struct {
		// First Link to the first page
		First *string `json:"first,omitempty"`

		// Last Link to the last page
		Last *string `json:"last,omitempty"`

		// Next Link to the next page (null if on last page)
		Next *string `json:"next"`

		// Previous Link to the previous page (null if on first page)
		Previous *string `json:"previous"`

		// Self Link to the current page
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`

	// NextCursor Opaque cursor for fetching the next page using keyset pagination.
	// Only present when hasNext is true.
	NextCursor *string `json:"nextCursor,omitempty"`

	// Page Current page number (1-indexed)
	Page int `json:"page"`

	// PreviousCursor Opaque cursor for fetching the previous page using keyset pagination.
	// Only present when hasPrevious is true.
	PreviousCursor *string `json:"previousCursor,omitempty"`

	// Size Number of items per page
	Size int `json:"size"`

	// TotalItems Total number of items across all pages
	TotalItems int `json:"totalItems"`

	// TotalPages Total number of pages
	TotalPages int `json:"totalPages"`
}

// PaginationLinks HATEOAS links for pagination navigation
type PaginationLinks struct {
	// First Link to the first page
	First *string `json:"first,omitempty"`

	// Last Link to the last page
	Last *string `json:"last,omitempty"`

	// Next Link to the next page (null if on last page)
	Next *string `json:"next"`

	// Previous Link to the previous page (null if on first page)
	Previous *string `json:"previous"`

	// Self Link to the current page
	Self *string `json:"self,omitempty"`
}

// PatchDeviceRequest Request body for partially updating a device (PATCH)
type PatchDeviceRequest struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The state of the device
	State *PatchDeviceRequestState `json:"state,omitempty"`
}

// PatchDeviceRequestState The state of the device
type PatchDeviceRequestState string

// PoolStats Connection pool statistics
type PoolStats struct {
	// Hits Number of successful pool hits
	Hits *int `json:"hits,omitempty"`

	// IdleConnections Number of idle connections in the pool
	IdleConnections *int `json:"idleConnections,omitempty"`

	// Misses Number of pool misses
	Misses *int `json:"misses,omitempty"`

	// StaleConnections Number of stale connections removed from the pool
	StaleConnections *int `json:"staleConnections,omitempty"`

	// Timeouts Number of connection timeouts
	Timeouts *int `json:"timeouts,omitempty"`

	// TotalConnections Total number of connections in the pool
	TotalConnections *int `json:"totalConnections,omitempty"`

	// WaitCount Number of times a connection was waited for
	WaitCount *int `json:"waitCount,omitempty"`

	// WaitDurationNs Total time spent waiting for connections in nanoseconds
	WaitDurationNs *int `json:"waitDurationNs,omitempty"`
}

// ReadinessResponse Readiness probe response with dependency status
type ReadinessResponse struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *struct {
				// Details Cache-specific details
				Details *struct {
					// PoolStats Connection pool statistics
					PoolStats *struct {
						// Hits Number of successful pool hits
						Hits *int `json:"hits,omitempty"`

						// IdleConnections Number of idle connections in the pool
						IdleConnections *int `json:"idleConnections,omitempty"`

						// Misses Number of pool misses
						Misses *int `json:"misses,omitempty"`

						// StaleConnections Number of stale connections removed from the pool
						StaleConnections *int `json:"staleConnections,omitempty"`

						// Timeouts Number of connection timeouts
						Timeouts *int `json:"timeouts,omitempty"`

						// TotalConnections Total number of connections in the pool
						TotalConnections *int `json:"totalConnections,omitempty"`

						// WaitCount Number of times a connection was waited for
						WaitCount *int `json:"waitCount,omitempty"`

						// WaitDurationNs Total time spent waiting for connections in nanoseconds
						WaitDurationNs *int `json:"waitDurationNs,omitempty"`
					} `json:"poolStats,omitempty"`

					// TotalKeys Total number of keys in the cache
					TotalKeys *int `json:"totalKeys,omitempty"`
				} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksInfraCacheStatus `json:"status"`
			} `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksInfraStorageStatus `json:"status"`
			} `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksServicesDevicesStatus `json:"status"`
			} `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall readiness status of the service
	Status ReadinessResponseStatus `json:"status"`

	// Timestamp Timestamp of the readiness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version (optional)
	Version *string `json:"version,omitempty"`
}

// ReadinessResponseChecksInfraCacheStatus The status of the dependency
type ReadinessResponseChecksInfraCacheStatus string

// ReadinessResponseChecksInfraStorageStatus The status of the dependency
type ReadinessResponseChecksInfraStorageStatus string

// ReadinessResponseChecksServicesDevicesStatus The status of the dependency
type ReadinessResponseChecksServicesDevicesStatus string

// ReadinessResponseStatus The overall readiness status of the service
type ReadinessResponseStatus string

// SystemInfo System resource information
type SystemInfo struct {
	// CpuCores Number of CPU cores available
	CpuCores *int `json:"cpuCores,omitempty"`

	// Goroutines Number of active goroutines
	Goroutines *int `json:"goroutines,omitempty"`

	// Memory Memory usage information
	Memory *struct {
		// AllocMb Current memory allocation in MB
		AllocMb *float32 `json:"allocMb,omitempty"`

		// GcCycles Number of completed GC cycles
		GcCycles *int `json:"gcCycles,omitempty"`

		// SysMb Total memory obtained from the OS in MB
		SysMb *float32 `json:"sysMb,omitempty"`

		// TotalAllocMb Total memory allocated since start in MB
		TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
	} `json:"memory,omitempty"`
}

// UpdateDeviceRequest Request body for fully updating a device (PUT)
type UpdateDeviceRequest struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The state of the device
	State UpdateDeviceRequestState `json:"state"`
}

// UpdateDeviceRequestState The state of the device
type UpdateDeviceRequestState string

// UptimeInfo Service uptime information
type UptimeInfo struct {
	// Duration Human-readable uptime duration
	Duration string `json:"duration"`

	// DurationSeconds Uptime in seconds
	DurationSeconds *int `json:"durationSeconds,omitempty"`

	// StartedAt Timestamp when the service started
	StartedAt time.Time `json:"startedAt"`
}

// VersionInfo Version information about the service
type VersionInfo struct {
	// Api API version
	Api string `json:"api"`

	// Build Build version or commit hash
	Build string `json:"build"`

	// Go Go runtime version
	Go *string `json:"go,omitempty"`
}

// AcceptEncodingHeader defines model for AcceptEncodingHeader.
type AcceptEncodingHeader = string

// AcceptHeader defines model for AcceptHeader.
type AcceptHeader = string

// ApiVersionHeader defines model for ApiVersionHeader.
type ApiVersionHeader string

// AuthorizationHeader defines model for AuthorizationHeader.
type AuthorizationHeader = string

// BrandFilterParam defines model for BrandFilterParam.
type BrandFilterParam = []string

// CorrelationIdHeader defines model for CorrelationIdHeader.
type CorrelationIdHeader = openapi_types.UUID

// CursorParam defines model for CursorParam.
type CursorParam = string

// DeviceIdParam defines model for DeviceIdParam.
type DeviceIdParam = openapi_types.UUID

// FieldsParam defines model for FieldsParam.
type FieldsParam = string

// IdempotencyKeyHeader defines model for IdempotencyKeyHeader.
type IdempotencyKeyHeader = openapi_types.UUID

// IfMatchHeader defines model for IfMatchHeader.
type IfMatchHeader = string

// IfNoneMatchHeader defines model for IfNoneMatchHeader.
type IfNoneMatchHeader = string

// PageParam defines model for PageParam.
type PageParam = int

// RequestIdHeader defines model for RequestIdHeader.
type RequestIdHeader = openapi_types.UUID

// SearchParam defines model for SearchParam.
type SearchParam = string

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = []string

// StateFilterParam defines model for StateFilterParam.
type StateFilterParam = []string

// TraceparentHeader defines model for TraceparentHeader.
type TraceparentHeader = string

// TracestateHeader defines model for TracestateHeader.
type TracestateHeader = string

// BadRequest Standard error response format
type BadRequest struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// Conflict Standard error response format
type Conflict struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// NotAcceptable Standard error response format
type NotAcceptable struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// NotFound Standard error response format
type NotFound struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// PreconditionFailed Standard error response format
type PreconditionFailed struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// RateLimit Standard error response format
type RateLimit struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ServerError Standard error response format
type ServerError struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// Unauthorized Standard error response format
type Unauthorized struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// UnprocessableEntity Standard error response format
type UnprocessableEntity struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter by brand(s). Comma-separated for OR matching.
	// Example: ?brand=Apple,Samsung
	Brand *[]string `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter by state(s). Comma-separated for OR matching.
	// Example: ?state=available,inactive
	State *[]ListDevicesParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Sort Fields to sort results by. Comma-separated for multi-field sorting.
	// Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	// Example: ?sort=-createdAt,name (sort by createdAt DESC, then name ASC)
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`

	// Q Full-text search query across name and brand fields.
	// Uses PostgreSQL full-text search with English language stemming.
	//
	// **Features:**
	// - Matches word variations (e.g., "running" matches "run")
	// - Case-insensitive search
	// - Searches both name and brand fields
	//
	// **Examples:**
	// - `?q=iPhone` - matches "iPhone 15 Pro", "My iPhone", etc.
	// - `?q=Samsung` - matches devices with Samsung brand
	// - `?q=Galaxy` - matches "Galaxy S24", "Galaxy Tab", etc.
	//
	// **Combining with filters:**
	// - `?q=iPhone&state=available` - available iPhones only
	// - `?q=Pro&brand=Apple` - Apple devices with "Pro" in name
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Cursor Opaque cursor for keyset-based pagination.
	// When provided, the `page` parameter is ignored.
	//
	// **Usage:**
	// 1. First request: Don't include cursor (uses page-based pagination)
	// 2. Subsequent requests: Use `pagination.nextCursor` or `pagination.previousCursor` from previous response
	//
	// **Benefits over offset pagination:**
	// - Stable results even when data changes between requests
	// - Better performance for large datasets (no OFFSET scanning)
	// - Consistent page sizes
	//
	// **Note:** Cursors are opaque strings - do not parse or modify them.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ListDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// ListDevicesParamsState defines parameters for ListDevices.
type ListDevicesParamsState string

// ListDevicesParamsAPIVersion defines parameters for ListDevices.
type ListDevicesParamsAPIVersion string

// HeadDevicesParams defines parameters for HeadDevices.
type HeadDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter by brand(s). Comma-separated for OR matching.
	// Example: ?brand=Apple,Samsung
	Brand *[]string `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter by state(s). Comma-separated for OR matching.
	// Example: ?state=available,inactive
	State *[]HeadDevicesParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Sort Fields to sort results by. Comma-separated for multi-field sorting.
	// Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	// Example: ?sort=-createdAt,name (sort by createdAt DESC, then name ASC)
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`

	// Q Full-text search query across name and brand fields.
	// Uses PostgreSQL full-text search with English language stemming.
	//
	// **Features:**
	// - Matches word variations (e.g., "running" matches "run")
	// - Case-insensitive search
	// - Searches both name and brand fields
	//
	// **Examples:**
	// - `?q=iPhone` - matches "iPhone 15 Pro", "My iPhone", etc.
	// - `?q=Samsung` - matches devices with Samsung brand
	// - `?q=Galaxy` - matches "Galaxy S24", "Galaxy Tab", etc.
	//
	// **Combining with filters:**
	// - `?q=iPhone&state=available` - available iPhones only
	// - `?q=Pro&brand=Apple` - Apple devices with "Pro" in name
	Q *string `form:"q,omitempty" json:"q,omitempty"`

	// Cursor Opaque cursor for keyset-based pagination.
	// When provided, the `page` parameter is ignored.
	//
	// **Usage:**
	// 1. First request: Don't include cursor (uses page-based pagination)
	// 2. Subsequent requests: Use `pagination.nextCursor` or `pagination.previousCursor` from previous response
	//
	// **Benefits over offset pagination:**
	// - Stable results even when data changes between requests
	// - Better performance for large datasets (no OFFSET scanning)
	// - Consistent page sizes
	//
	// **Note:** Cursors are opaque strings - do not parse or modify them.
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadDevicesParamsState defines parameters for HeadDevices.
type HeadDevicesParamsState string

// HeadDevicesParamsAPIVersion defines parameters for HeadDevices.
type HeadDevicesParamsAPIVersion string

// CreateDeviceJSONBody defines parameters for CreateDevice.
type CreateDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State Initial state of the device (defaults to "available" if not provided)
	State *CreateDeviceJSONBodyState `json:"state,omitempty"`
}

// CreateDeviceParams defines parameters for CreateDevice.
type CreateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *CreateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IdempotencyKey Unique key to ensure idempotent POST requests.
	// If the same key is sent again within the TTL window (24 hours),
	// the server returns the cached response instead of creating a duplicate.
	//
	// **Requirements:**
	// - Must be a valid UUID v7
	// - Must be unique per logical operation
	// - Cached for 24 hours
	IdempotencyKey openapi_types.UUID `json:"Idempotency-Key"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// CreateDeviceParamsAPIVersion defines parameters for CreateDevice.
type CreateDeviceParamsAPIVersion string

// CreateDeviceJSONBodyState defines parameters for CreateDevice.
type CreateDeviceJSONBodyState string

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *DeleteDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`
}

// DeleteDeviceParamsAPIVersion defines parameters for DeleteDevice.
type DeleteDeviceParamsAPIVersion string

// GetDeviceParams defines parameters for GetDevice.
type GetDeviceParams struct {
	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *GetDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// GetDeviceParamsAPIVersion defines parameters for GetDevice.
type GetDeviceParamsAPIVersion string

// HeadDeviceParams defines parameters for HeadDevice.
type HeadDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadDeviceParamsAPIVersion defines parameters for HeadDevice.
type HeadDeviceParamsAPIVersion string

// PatchDeviceJSONBody defines parameters for PatchDevice.
type PatchDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The state of the device
	State *PatchDeviceJSONBodyState `json:"state,omitempty"`
}

// PatchDeviceParams defines parameters for PatchDevice.
type PatchDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *PatchDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// PatchDeviceParamsAPIVersion defines parameters for PatchDevice.
type PatchDeviceParamsAPIVersion string

// PatchDeviceJSONBodyState defines parameters for PatchDevice.
type PatchDeviceJSONBodyState string

// UpdateDeviceJSONBody defines parameters for UpdateDevice.
type UpdateDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The state of the device
	State UpdateDeviceJSONBodyState `json:"state"`
}

// UpdateDeviceParams defines parameters for UpdateDevice.
type UpdateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *UpdateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// UpdateDeviceParamsAPIVersion defines parameters for UpdateDevice.
type UpdateDeviceParamsAPIVersion string

// UpdateDeviceJSONBodyState defines parameters for UpdateDevice.
type UpdateDeviceJSONBodyState string

// CreateDeviceJSONRequestBody defines body for CreateDevice for application/json ContentType.
type CreateDeviceJSONRequestBody CreateDeviceJSONBody

// PatchDeviceJSONRequestBody defines body for PatchDevice for application/json ContentType.
type PatchDeviceJSONRequestBody PatchDeviceJSONBody

// UpdateDeviceJSONRequestBody defines body for UpdateDevice for application/json ContentType.
type UpdateDeviceJSONRequestBody UpdateDeviceJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all devices
	// (GET /devices)
	ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams)
	// Get devices collection metadata
	// (HEAD /devices)
	HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams)
	// Get allowed methods for devices collection
	// (OPTIONS /devices)
	OptionsDevices(w http.ResponseWriter, r *http.Request)
	// Create a new device
	// (POST /devices)
	CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams)
	// Delete a device
	// (DELETE /devices/{deviceId})
	DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params DeleteDeviceParams)
	// Get a device by ID
	// (GET /devices/{deviceId})
	GetDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params GetDeviceParams)
	// Get device metadata
	// (HEAD /devices/{deviceId})
	HeadDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params HeadDeviceParams)
	// Get allowed methods for device resource
	// (OPTIONS /devices/{deviceId})
	OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID)
	// Partially update a device
	// (PATCH /devices/{deviceId})
	PatchDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params PatchDeviceParams)
	// Fully update a device
	// (PUT /devices/{deviceId})
	UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params UpdateDeviceParams)
	// Health check
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// Liveness probe
	// (GET /liveness)
	LivenessCheck(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /readiness)
	ReadinessCheck(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List all devices
// (GET /devices)
func (_ Unimplemented) ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get devices collection metadata
// (HEAD /devices)
func (_ Unimplemented) HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for devices collection
// (OPTIONS /devices)
func (_ Unimplemented) OptionsDevices(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new device
// (POST /devices)
func (_ Unimplemented) CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a device
// (DELETE /devices/{deviceId})
func (_ Unimplemented) DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params DeleteDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a device by ID
// (GET /devices/{deviceId})
func (_ Unimplemented) GetDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params GetDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get device metadata
// (HEAD /devices/{deviceId})
func (_ Unimplemented) HeadDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params HeadDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for device resource
// (OPTIONS /devices/{deviceId})
func (_ Unimplemented) OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Partially update a device
// (PATCH /devices/{deviceId})
func (_ Unimplemented) PatchDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params PatchDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fully update a device
// (PUT /devices/{deviceId})
func (_ Unimplemented) UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params UpdateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /liveness)
func (_ Unimplemented) LivenessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /readiness)
func (_ Unimplemented) ReadinessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", false, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ListDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevices operation middleware
func (siw *ServerInterfaceWrapper) HeadDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", false, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevices operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevices(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevices(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateDevice operation middleware
func (siw *ServerInterfaceWrapper) CreateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion CreateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Required header parameter "Idempotency-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Idempotency-Key")]; found {
		var IdempotencyKey openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Idempotency-Key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Idempotency-Key", valueList[0], &IdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Idempotency-Key", Err: err})
			return
		}

		params.IdempotencyKey = IdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter Idempotency-Key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Idempotency-Key", Err: err})
		return
	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDevice(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDevice operation middleware
func (siw *ServerInterfaceWrapper) DeleteDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion DeleteDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDevice operation middleware
func (siw *ServerInterfaceWrapper) GetDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDeviceParams

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion GetDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevice operation middleware
func (siw *ServerInterfaceWrapper) HeadDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevice operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevice(w, r, deviceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchDevice operation middleware
func (siw *ServerInterfaceWrapper) PatchDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion PatchDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateDevice operation middleware
func (siw *ServerInterfaceWrapper) UpdateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion UpdateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LivenessCheck operation middleware
func (siw *ServerInterfaceWrapper) LivenessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LivenessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadinessCheck operation middleware
func (siw *ServerInterfaceWrapper) ReadinessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadinessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices", wrapper.ListDevices)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices", wrapper.HeadDevices)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices", wrapper.OptionsDevices)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/devices", wrapper.CreateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/devices/{deviceId}", wrapper.DeleteDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices/{deviceId}", wrapper.GetDevice)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices/{deviceId}", wrapper.HeadDevice)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices/{deviceId}", wrapper.OptionsDevice)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/devices/{deviceId}", wrapper.PatchDevice)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/devices/{deviceId}", wrapper.UpdateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/liveness", wrapper.LivenessCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/readiness", wrapper.ReadinessCheck)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
