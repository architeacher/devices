// Package handlers provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package handlers

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	PasetoAuthScopes = "PasetoAuth.Scopes"
)

// Defines values for AppliedFiltersState.
const (
	AppliedFiltersStateAvailable AppliedFiltersState = "available"
	AppliedFiltersStateInUse     AppliedFiltersState = "in-use"
	AppliedFiltersStateInactive  AppliedFiltersState = "inactive"
)

// Defines values for CacheDependencyCheckStatus.
const (
	CacheDependencyCheckStatusDegraded CacheDependencyCheckStatus = "degraded"
	CacheDependencyCheckStatusDown     CacheDependencyCheckStatus = "down"
	CacheDependencyCheckStatusUnknown  CacheDependencyCheckStatus = "unknown"
	CacheDependencyCheckStatusUp       CacheDependencyCheckStatus = "up"
)

// Defines values for CreateDeviceRequestState.
const (
	CreateDeviceRequestStateAvailable CreateDeviceRequestState = "available"
	CreateDeviceRequestStateInUse     CreateDeviceRequestState = "in-use"
	CreateDeviceRequestStateInactive  CreateDeviceRequestState = "inactive"
)

// Defines values for DependencyCheckStatus.
const (
	DependencyCheckStatusDegraded DependencyCheckStatus = "degraded"
	DependencyCheckStatusDown     DependencyCheckStatus = "down"
	DependencyCheckStatusUnknown  DependencyCheckStatus = "unknown"
	DependencyCheckStatusUp       DependencyCheckStatus = "up"
)

// Defines values for DeviceState.
const (
	DeviceStateAvailable DeviceState = "available"
	DeviceStateInUse     DeviceState = "in-use"
	DeviceStateInactive  DeviceState = "inactive"
)

// Defines values for DeviceListResponseDataState.
const (
	DeviceListResponseDataStateAvailable DeviceListResponseDataState = "available"
	DeviceListResponseDataStateInUse     DeviceListResponseDataState = "in-use"
	DeviceListResponseDataStateInactive  DeviceListResponseDataState = "inactive"
)

// Defines values for DeviceListResponseFiltersState.
const (
	DeviceListResponseFiltersStateAvailable DeviceListResponseFiltersState = "available"
	DeviceListResponseFiltersStateInUse     DeviceListResponseFiltersState = "in-use"
	DeviceListResponseFiltersStateInactive  DeviceListResponseFiltersState = "inactive"
)

// Defines values for DeviceResponseDataState.
const (
	DeviceResponseDataStateAvailable DeviceResponseDataState = "available"
	DeviceResponseDataStateInUse     DeviceResponseDataState = "in-use"
	DeviceResponseDataStateInactive  DeviceResponseDataState = "inactive"
)

// Defines values for HealthResponseChecksInfraCacheStatus.
const (
	HealthResponseChecksInfraCacheStatusDegraded HealthResponseChecksInfraCacheStatus = "degraded"
	HealthResponseChecksInfraCacheStatusDown     HealthResponseChecksInfraCacheStatus = "down"
	HealthResponseChecksInfraCacheStatusUnknown  HealthResponseChecksInfraCacheStatus = "unknown"
	HealthResponseChecksInfraCacheStatusUp       HealthResponseChecksInfraCacheStatus = "up"
)

// Defines values for HealthResponseChecksInfraStorageStatus.
const (
	HealthResponseChecksInfraStorageStatusDegraded HealthResponseChecksInfraStorageStatus = "degraded"
	HealthResponseChecksInfraStorageStatusDown     HealthResponseChecksInfraStorageStatus = "down"
	HealthResponseChecksInfraStorageStatusUnknown  HealthResponseChecksInfraStorageStatus = "unknown"
	HealthResponseChecksInfraStorageStatusUp       HealthResponseChecksInfraStorageStatus = "up"
)

// Defines values for HealthResponseChecksServicesDevicesStatus.
const (
	HealthResponseChecksServicesDevicesStatusDegraded HealthResponseChecksServicesDevicesStatus = "degraded"
	HealthResponseChecksServicesDevicesStatusDown     HealthResponseChecksServicesDevicesStatus = "down"
	HealthResponseChecksServicesDevicesStatusUnknown  HealthResponseChecksServicesDevicesStatus = "unknown"
	HealthResponseChecksServicesDevicesStatusUp       HealthResponseChecksServicesDevicesStatus = "up"
)

// Defines values for HealthResponseStatus.
const (
	HealthResponseStatusDegraded    HealthResponseStatus = "degraded"
	HealthResponseStatusDown        HealthResponseStatus = "down"
	HealthResponseStatusMaintenance HealthResponseStatus = "maintenance"
	HealthResponseStatusOk          HealthResponseStatus = "ok"
)

// Defines values for LivenessResponseStatus.
const (
	LivenessResponseStatusDegraded    LivenessResponseStatus = "degraded"
	LivenessResponseStatusDown        LivenessResponseStatus = "down"
	LivenessResponseStatusMaintenance LivenessResponseStatus = "maintenance"
	LivenessResponseStatusOk          LivenessResponseStatus = "ok"
)

// Defines values for PatchDeviceRequestState.
const (
	PatchDeviceRequestStateAvailable PatchDeviceRequestState = "available"
	PatchDeviceRequestStateInUse     PatchDeviceRequestState = "in-use"
	PatchDeviceRequestStateInactive  PatchDeviceRequestState = "inactive"
)

// Defines values for ReadinessResponseChecksInfraCacheStatus.
const (
	ReadinessResponseChecksInfraCacheStatusDegraded ReadinessResponseChecksInfraCacheStatus = "degraded"
	ReadinessResponseChecksInfraCacheStatusDown     ReadinessResponseChecksInfraCacheStatus = "down"
	ReadinessResponseChecksInfraCacheStatusUnknown  ReadinessResponseChecksInfraCacheStatus = "unknown"
	ReadinessResponseChecksInfraCacheStatusUp       ReadinessResponseChecksInfraCacheStatus = "up"
)

// Defines values for ReadinessResponseChecksInfraStorageStatus.
const (
	ReadinessResponseChecksInfraStorageStatusDegraded ReadinessResponseChecksInfraStorageStatus = "degraded"
	ReadinessResponseChecksInfraStorageStatusDown     ReadinessResponseChecksInfraStorageStatus = "down"
	ReadinessResponseChecksInfraStorageStatusUnknown  ReadinessResponseChecksInfraStorageStatus = "unknown"
	ReadinessResponseChecksInfraStorageStatusUp       ReadinessResponseChecksInfraStorageStatus = "up"
)

// Defines values for ReadinessResponseChecksServicesDevicesStatus.
const (
	ReadinessResponseChecksServicesDevicesStatusDegraded ReadinessResponseChecksServicesDevicesStatus = "degraded"
	ReadinessResponseChecksServicesDevicesStatusDown     ReadinessResponseChecksServicesDevicesStatus = "down"
	ReadinessResponseChecksServicesDevicesStatusUnknown  ReadinessResponseChecksServicesDevicesStatus = "unknown"
	ReadinessResponseChecksServicesDevicesStatusUp       ReadinessResponseChecksServicesDevicesStatus = "up"
)

// Defines values for ReadinessResponseStatus.
const (
	Degraded    ReadinessResponseStatus = "degraded"
	Down        ReadinessResponseStatus = "down"
	Maintenance ReadinessResponseStatus = "maintenance"
	Ok          ReadinessResponseStatus = "ok"
)

// Defines values for UpdateDeviceRequestState.
const (
	UpdateDeviceRequestStateAvailable UpdateDeviceRequestState = "available"
	UpdateDeviceRequestStateInUse     UpdateDeviceRequestState = "in-use"
	UpdateDeviceRequestStateInactive  UpdateDeviceRequestState = "inactive"
)

// Defines values for ApiVersionHeader.
const (
	ApiVersionHeaderV1 ApiVersionHeader = "v1"
)

// Defines values for ListDevicesParamsState.
const (
	ListDevicesParamsStateAvailable ListDevicesParamsState = "available"
	ListDevicesParamsStateInUse     ListDevicesParamsState = "in-use"
	ListDevicesParamsStateInactive  ListDevicesParamsState = "inactive"
)

// Defines values for ListDevicesParamsAPIVersion.
const (
	ListDevicesParamsAPIVersionV1 ListDevicesParamsAPIVersion = "v1"
)

// Defines values for HeadDevicesParamsState.
const (
	HeadDevicesParamsStateAvailable HeadDevicesParamsState = "available"
	HeadDevicesParamsStateInUse     HeadDevicesParamsState = "in-use"
	HeadDevicesParamsStateInactive  HeadDevicesParamsState = "inactive"
)

// Defines values for HeadDevicesParamsAPIVersion.
const (
	HeadDevicesParamsAPIVersionV1 HeadDevicesParamsAPIVersion = "v1"
)

// Defines values for CreateDeviceParamsAPIVersion.
const (
	CreateDeviceParamsAPIVersionV1 CreateDeviceParamsAPIVersion = "v1"
)

// Defines values for CreateDeviceJSONBodyState.
const (
	CreateDeviceJSONBodyStateAvailable CreateDeviceJSONBodyState = "available"
	CreateDeviceJSONBodyStateInUse     CreateDeviceJSONBodyState = "in-use"
	CreateDeviceJSONBodyStateInactive  CreateDeviceJSONBodyState = "inactive"
)

// Defines values for DeleteDeviceParamsAPIVersion.
const (
	DeleteDeviceParamsAPIVersionV1 DeleteDeviceParamsAPIVersion = "v1"
)

// Defines values for GetDeviceParamsAPIVersion.
const (
	GetDeviceParamsAPIVersionV1 GetDeviceParamsAPIVersion = "v1"
)

// Defines values for HeadDeviceParamsAPIVersion.
const (
	HeadDeviceParamsAPIVersionV1 HeadDeviceParamsAPIVersion = "v1"
)

// Defines values for PatchDeviceParamsAPIVersion.
const (
	PatchDeviceParamsAPIVersionV1 PatchDeviceParamsAPIVersion = "v1"
)

// Defines values for PatchDeviceJSONBodyState.
const (
	PatchDeviceJSONBodyStateAvailable PatchDeviceJSONBodyState = "available"
	PatchDeviceJSONBodyStateInUse     PatchDeviceJSONBodyState = "in-use"
	PatchDeviceJSONBodyStateInactive  PatchDeviceJSONBodyState = "inactive"
)

// Defines values for UpdateDeviceParamsAPIVersion.
const (
	V1 UpdateDeviceParamsAPIVersion = "v1"
)

// Defines values for UpdateDeviceJSONBodyState.
const (
	Available UpdateDeviceJSONBodyState = "available"
	InUse     UpdateDeviceJSONBodyState = "in-use"
	Inactive  UpdateDeviceJSONBodyState = "inactive"
)

// AppliedFilters Filters that were applied to this request
type AppliedFilters struct {
	// Brand Brand filter that was applied
	Brand *string `json:"brand"`

	// State State filter that was applied
	State *AppliedFiltersState `json:"state"`
}

// AppliedFiltersState State filter that was applied
type AppliedFiltersState string

// CacheDependencyCheck defines model for CacheDependencyCheck.
type CacheDependencyCheck struct {
	// Details Cache-specific details
	Details *struct {
		// PoolStats Connection pool statistics
		PoolStats *struct {
			// Hits Number of successful pool hits
			Hits *int `json:"hits,omitempty"`

			// IdleConnections Number of idle connections in the pool
			IdleConnections *int `json:"idleConnections,omitempty"`

			// Misses Number of pool misses
			Misses *int `json:"misses,omitempty"`

			// StaleConnections Number of stale connections removed from the pool
			StaleConnections *int `json:"staleConnections,omitempty"`

			// Timeouts Number of connection timeouts
			Timeouts *int `json:"timeouts,omitempty"`

			// TotalConnections Total number of connections in the pool
			TotalConnections *int `json:"totalConnections,omitempty"`

			// WaitCount Number of times a connection was waited for
			WaitCount *int `json:"waitCount,omitempty"`

			// WaitDurationNs Total time spent waiting for connections in nanoseconds
			WaitDurationNs *int `json:"waitDurationNs,omitempty"`
		} `json:"poolStats,omitempty"`

		// TotalKeys Total number of keys in the cache
		TotalKeys *int `json:"totalKeys,omitempty"`
	} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status CacheDependencyCheckStatus `json:"status"`
}

// CacheDependencyCheckStatus The status of the dependency
type CacheDependencyCheckStatus string

// CreateDeviceRequest Request body for creating a new device
type CreateDeviceRequest struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State Initial state of the device (defaults to "available" if not provided)
	State *CreateDeviceRequestState `json:"state,omitempty"`
}

// CreateDeviceRequestState Initial state of the device (defaults to "available" if not provided)
type CreateDeviceRequestState string

// DependencyCheck Status of a single dependency
type DependencyCheck struct {
	// Details Additional dependency-specific details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status DependencyCheckStatus `json:"status"`
}

// DependencyCheckStatus The status of the dependency
type DependencyCheckStatus string

// Device A device resource
type Device struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// CreatedAt Timestamp when the device was created (immutable)
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique identifier for the device (UUID v7)
	Id openapi_types.UUID `json:"id"`

	// Links HATEOAS links for device navigation
	Links *struct {
		// Self Link to this device resource
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`

	// UpdatedAt Timestamp when the device was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// DeviceState The current state of the device
type DeviceState string

// DeviceLinks HATEOAS links for device navigation
type DeviceLinks struct {
	// Self Link to this device resource
	Self *string `json:"self,omitempty"`
}

// DeviceListResponse Response containing a paginated list of devices
type DeviceListResponse struct {
	// Data List of devices
	Data []struct {
		// Brand The brand/manufacturer of the device
		Brand string `json:"brand"`

		// CreatedAt Timestamp when the device was created (immutable)
		CreatedAt time.Time `json:"createdAt"`

		// Id Unique identifier for the device (UUID v7)
		Id openapi_types.UUID `json:"id"`

		// Links HATEOAS links for device navigation
		Links *struct {
			// Self Link to this device resource
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Name The name of the device
		Name string `json:"name"`

		// State The current state of the device
		State DeviceListResponseDataState `json:"state"`

		// UpdatedAt Timestamp when the device was last updated
		UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	} `json:"data"`

	// Filters Filters that were applied to this request
	Filters *struct {
		// Brand Brand filter that was applied
		Brand *string `json:"brand"`

		// State State filter that was applied
		State *DeviceListResponseFiltersState `json:"state"`
	} `json:"filters,omitempty"`

	// Pagination Pagination metadata for list responses
	Pagination struct {
		// HasNext Whether there is a next page
		HasNext *bool `json:"hasNext,omitempty"`

		// HasPrevious Whether there is a previous page
		HasPrevious *bool `json:"hasPrevious,omitempty"`

		// Links HATEOAS links for pagination navigation
		Links *struct {
			// First Link to the first page
			First *string `json:"first,omitempty"`

			// Last Link to the last page
			Last *string `json:"last,omitempty"`

			// Next Link to the next page (null if on last page)
			Next *string `json:"next"`

			// Previous Link to the previous page (null if on first page)
			Previous *string `json:"previous"`

			// Self Link to the current page
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Page Current page number (1-indexed)
		Page int `json:"page"`

		// Size Number of items per page
		Size int `json:"size"`

		// TotalItems Total number of items across all pages
		TotalItems int `json:"totalItems"`

		// TotalPages Total number of pages
		TotalPages int `json:"totalPages"`
	} `json:"pagination"`
}

// DeviceListResponseDataState The current state of the device
type DeviceListResponseDataState string

// DeviceListResponseFiltersState State filter that was applied
type DeviceListResponseFiltersState string

// DeviceResponse Response containing a single device
type DeviceResponse struct {
	// Data A device resource
	Data struct {
		// Brand The brand/manufacturer of the device
		Brand string `json:"brand"`

		// CreatedAt Timestamp when the device was created (immutable)
		CreatedAt time.Time `json:"createdAt"`

		// Id Unique identifier for the device (UUID v7)
		Id openapi_types.UUID `json:"id"`

		// Links HATEOAS links for device navigation
		Links *struct {
			// Self Link to this device resource
			Self *string `json:"self,omitempty"`
		} `json:"links,omitempty"`

		// Name The name of the device
		Name string `json:"name"`

		// State The current state of the device
		State DeviceResponseDataState `json:"state"`

		// UpdatedAt Timestamp when the device was last updated
		UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	} `json:"data"`
}

// DeviceResponseDataState The current state of the device
type DeviceResponseDataState string

// ErrorDetail Detailed information about a specific error
type ErrorDetail struct {
	// Code Machine-readable error code for this specific error
	Code *string `json:"code,omitempty"`

	// Field The field that caused the error
	Field string `json:"field"`

	// Message Description of what is wrong with the field
	Message string `json:"message"`
}

// ErrorResponse Standard error response format
type ErrorResponse struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// HealthResponse Comprehensive health check response with system metrics
type HealthResponse struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *struct {
				// Details Cache-specific details
				Details *struct {
					// PoolStats Connection pool statistics
					PoolStats *struct {
						// Hits Number of successful pool hits
						Hits *int `json:"hits,omitempty"`

						// IdleConnections Number of idle connections in the pool
						IdleConnections *int `json:"idleConnections,omitempty"`

						// Misses Number of pool misses
						Misses *int `json:"misses,omitempty"`

						// StaleConnections Number of stale connections removed from the pool
						StaleConnections *int `json:"staleConnections,omitempty"`

						// Timeouts Number of connection timeouts
						Timeouts *int `json:"timeouts,omitempty"`

						// TotalConnections Total number of connections in the pool
						TotalConnections *int `json:"totalConnections,omitempty"`

						// WaitCount Number of times a connection was waited for
						WaitCount *int `json:"waitCount,omitempty"`

						// WaitDurationNs Total time spent waiting for connections in nanoseconds
						WaitDurationNs *int `json:"waitDurationNs,omitempty"`
					} `json:"poolStats,omitempty"`

					// TotalKeys Total number of keys in the cache
					TotalKeys *int `json:"totalKeys,omitempty"`
				} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksInfraCacheStatus `json:"status"`
			} `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksInfraStorageStatus `json:"status"`
			} `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status HealthResponseChecksServicesDevicesStatus `json:"status"`
			} `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall health status of the service
	Status HealthResponseStatus `json:"status"`

	// System System resource information
	System *struct {
		// CpuCores Number of CPU cores available
		CpuCores *int `json:"cpuCores,omitempty"`

		// Goroutines Number of active goroutines
		Goroutines *int `json:"goroutines,omitempty"`

		// Memory Memory usage information
		Memory *struct {
			// AllocMb Current memory allocation in MB
			AllocMb *float32 `json:"allocMb,omitempty"`

			// GcCycles Number of completed GC cycles
			GcCycles *int `json:"gcCycles,omitempty"`

			// SysMb Total memory obtained from the OS in MB
			SysMb *float32 `json:"sysMb,omitempty"`

			// TotalAllocMb Total memory allocated since start in MB
			TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
		} `json:"memory,omitempty"`
	} `json:"system,omitempty"`

	// Timestamp Timestamp of the health check
	Timestamp time.Time `json:"timestamp"`

	// Uptime Service uptime information
	Uptime struct {
		// Duration Human-readable uptime duration
		Duration string `json:"duration"`

		// DurationSeconds Uptime in seconds
		DurationSeconds *int `json:"durationSeconds,omitempty"`

		// StartedAt Timestamp when the service started
		StartedAt time.Time `json:"startedAt"`
	} `json:"uptime"`

	// Version Version information about the service
	Version struct {
		// Api API version
		Api string `json:"api"`

		// Build Build version or commit hash
		Build string `json:"build"`

		// Go Go runtime version
		Go *string `json:"go,omitempty"`
	} `json:"version"`
}

// HealthResponseChecksInfraCacheStatus The status of the dependency
type HealthResponseChecksInfraCacheStatus string

// HealthResponseChecksInfraStorageStatus The status of the dependency
type HealthResponseChecksInfraStorageStatus string

// HealthResponseChecksServicesDevicesStatus The status of the dependency
type HealthResponseChecksServicesDevicesStatus string

// HealthResponseStatus The overall health status of the service
type HealthResponseStatus string

// LivenessResponse Liveness probe response
type LivenessResponse struct {
	// Status The liveness status of the service
	Status LivenessResponseStatus `json:"status"`

	// Timestamp Timestamp of the liveness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version string `json:"version"`
}

// LivenessResponseStatus The liveness status of the service
type LivenessResponseStatus string

// MemoryInfo Memory usage information
type MemoryInfo struct {
	// AllocMb Current memory allocation in MB
	AllocMb *float32 `json:"allocMb,omitempty"`

	// GcCycles Number of completed GC cycles
	GcCycles *int `json:"gcCycles,omitempty"`

	// SysMb Total memory obtained from the OS in MB
	SysMb *float32 `json:"sysMb,omitempty"`

	// TotalAllocMb Total memory allocated since start in MB
	TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
}

// Pagination Pagination metadata for list responses
type Pagination struct {
	// HasNext Whether there is a next page
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrevious Whether there is a previous page
	HasPrevious *bool `json:"hasPrevious,omitempty"`

	// Links HATEOAS links for pagination navigation
	Links *struct {
		// First Link to the first page
		First *string `json:"first,omitempty"`

		// Last Link to the last page
		Last *string `json:"last,omitempty"`

		// Next Link to the next page (null if on last page)
		Next *string `json:"next"`

		// Previous Link to the previous page (null if on first page)
		Previous *string `json:"previous"`

		// Self Link to the current page
		Self *string `json:"self,omitempty"`
	} `json:"links,omitempty"`

	// Page Current page number (1-indexed)
	Page int `json:"page"`

	// Size Number of items per page
	Size int `json:"size"`

	// TotalItems Total number of items across all pages
	TotalItems int `json:"totalItems"`

	// TotalPages Total number of pages
	TotalPages int `json:"totalPages"`
}

// PaginationLinks HATEOAS links for pagination navigation
type PaginationLinks struct {
	// First Link to the first page
	First *string `json:"first,omitempty"`

	// Last Link to the last page
	Last *string `json:"last,omitempty"`

	// Next Link to the next page (null if on last page)
	Next *string `json:"next"`

	// Previous Link to the previous page (null if on first page)
	Previous *string `json:"previous"`

	// Self Link to the current page
	Self *string `json:"self,omitempty"`
}

// PatchDeviceRequest Request body for partially updating a device (PATCH)
type PatchDeviceRequest struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The state of the device
	State *PatchDeviceRequestState `json:"state,omitempty"`
}

// PatchDeviceRequestState The state of the device
type PatchDeviceRequestState string

// PoolStats Connection pool statistics
type PoolStats struct {
	// Hits Number of successful pool hits
	Hits *int `json:"hits,omitempty"`

	// IdleConnections Number of idle connections in the pool
	IdleConnections *int `json:"idleConnections,omitempty"`

	// Misses Number of pool misses
	Misses *int `json:"misses,omitempty"`

	// StaleConnections Number of stale connections removed from the pool
	StaleConnections *int `json:"staleConnections,omitempty"`

	// Timeouts Number of connection timeouts
	Timeouts *int `json:"timeouts,omitempty"`

	// TotalConnections Total number of connections in the pool
	TotalConnections *int `json:"totalConnections,omitempty"`

	// WaitCount Number of times a connection was waited for
	WaitCount *int `json:"waitCount,omitempty"`

	// WaitDurationNs Total time spent waiting for connections in nanoseconds
	WaitDurationNs *int `json:"waitDurationNs,omitempty"`
}

// ReadinessResponse Readiness probe response with dependency status
type ReadinessResponse struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *struct {
				// Details Cache-specific details
				Details *struct {
					// PoolStats Connection pool statistics
					PoolStats *struct {
						// Hits Number of successful pool hits
						Hits *int `json:"hits,omitempty"`

						// IdleConnections Number of idle connections in the pool
						IdleConnections *int `json:"idleConnections,omitempty"`

						// Misses Number of pool misses
						Misses *int `json:"misses,omitempty"`

						// StaleConnections Number of stale connections removed from the pool
						StaleConnections *int `json:"staleConnections,omitempty"`

						// Timeouts Number of connection timeouts
						Timeouts *int `json:"timeouts,omitempty"`

						// TotalConnections Total number of connections in the pool
						TotalConnections *int `json:"totalConnections,omitempty"`

						// WaitCount Number of times a connection was waited for
						WaitCount *int `json:"waitCount,omitempty"`

						// WaitDurationNs Total time spent waiting for connections in nanoseconds
						WaitDurationNs *int `json:"waitDurationNs,omitempty"`
					} `json:"poolStats,omitempty"`

					// TotalKeys Total number of keys in the cache
					TotalKeys *int `json:"totalKeys,omitempty"`
				} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksInfraCacheStatus `json:"status"`
			} `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksInfraStorageStatus `json:"status"`
			} `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices struct {
				// Details Additional dependency-specific details
				Details *map[string]interface{} `json:"details,omitempty"`

				// Error Error message if the dependency is unhealthy
				Error *string `json:"error,omitempty"`

				// LastChecked Timestamp of the last health check for this dependency
				LastChecked *time.Time `json:"lastChecked,omitempty"`

				// LatencyMs Latency of the last health check in milliseconds
				LatencyMs *int `json:"latencyMs,omitempty"`

				// Message Additional information about the dependency status
				Message *string `json:"message,omitempty"`

				// Status The status of the dependency
				Status ReadinessResponseChecksServicesDevicesStatus `json:"status"`
			} `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall readiness status of the service
	Status ReadinessResponseStatus `json:"status"`

	// Timestamp Timestamp of the readiness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version (optional)
	Version *string `json:"version,omitempty"`
}

// ReadinessResponseChecksInfraCacheStatus The status of the dependency
type ReadinessResponseChecksInfraCacheStatus string

// ReadinessResponseChecksInfraStorageStatus The status of the dependency
type ReadinessResponseChecksInfraStorageStatus string

// ReadinessResponseChecksServicesDevicesStatus The status of the dependency
type ReadinessResponseChecksServicesDevicesStatus string

// ReadinessResponseStatus The overall readiness status of the service
type ReadinessResponseStatus string

// SystemInfo System resource information
type SystemInfo struct {
	// CpuCores Number of CPU cores available
	CpuCores *int `json:"cpuCores,omitempty"`

	// Goroutines Number of active goroutines
	Goroutines *int `json:"goroutines,omitempty"`

	// Memory Memory usage information
	Memory *struct {
		// AllocMb Current memory allocation in MB
		AllocMb *float32 `json:"allocMb,omitempty"`

		// GcCycles Number of completed GC cycles
		GcCycles *int `json:"gcCycles,omitempty"`

		// SysMb Total memory obtained from the OS in MB
		SysMb *float32 `json:"sysMb,omitempty"`

		// TotalAllocMb Total memory allocated since start in MB
		TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
	} `json:"memory,omitempty"`
}

// UpdateDeviceRequest Request body for fully updating a device (PUT)
type UpdateDeviceRequest struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The state of the device
	State UpdateDeviceRequestState `json:"state"`
}

// UpdateDeviceRequestState The state of the device
type UpdateDeviceRequestState string

// UptimeInfo Service uptime information
type UptimeInfo struct {
	// Duration Human-readable uptime duration
	Duration string `json:"duration"`

	// DurationSeconds Uptime in seconds
	DurationSeconds *int `json:"durationSeconds,omitempty"`

	// StartedAt Timestamp when the service started
	StartedAt time.Time `json:"startedAt"`
}

// VersionInfo Version information about the service
type VersionInfo struct {
	// Api API version
	Api string `json:"api"`

	// Build Build version or commit hash
	Build string `json:"build"`

	// Go Go runtime version
	Go *string `json:"go,omitempty"`
}

// AcceptEncodingHeader defines model for AcceptEncodingHeader.
type AcceptEncodingHeader = string

// AcceptHeader defines model for AcceptHeader.
type AcceptHeader = string

// ApiVersionHeader defines model for ApiVersionHeader.
type ApiVersionHeader string

// AuthorizationHeader defines model for AuthorizationHeader.
type AuthorizationHeader = string

// BrandFilterParam defines model for BrandFilterParam.
type BrandFilterParam = []string

// CorrelationIdHeader defines model for CorrelationIdHeader.
type CorrelationIdHeader = openapi_types.UUID

// DeviceIdParam defines model for DeviceIdParam.
type DeviceIdParam = openapi_types.UUID

// FieldsParam defines model for FieldsParam.
type FieldsParam = string

// IdempotencyKeyHeader defines model for IdempotencyKeyHeader.
type IdempotencyKeyHeader = openapi_types.UUID

// IfMatchHeader defines model for IfMatchHeader.
type IfMatchHeader = string

// IfNoneMatchHeader defines model for IfNoneMatchHeader.
type IfNoneMatchHeader = string

// PageParam defines model for PageParam.
type PageParam = int

// RequestIdHeader defines model for RequestIdHeader.
type RequestIdHeader = openapi_types.UUID

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = []string

// StateFilterParam defines model for StateFilterParam.
type StateFilterParam = []string

// TraceparentHeader defines model for TraceparentHeader.
type TraceparentHeader = string

// TracestateHeader defines model for TracestateHeader.
type TracestateHeader = string

// BadRequest Standard error response format
type BadRequest struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// Conflict Standard error response format
type Conflict struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// NotAcceptable Standard error response format
type NotAcceptable struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// NotFound Standard error response format
type NotFound struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// PreconditionFailed Standard error response format
type PreconditionFailed struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// RateLimit Standard error response format
type RateLimit struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ServerError Standard error response format
type ServerError struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// Unauthorized Standard error response format
type Unauthorized struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// UnprocessableEntity Standard error response format
type UnprocessableEntity struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]struct {
		// Code Machine-readable error code for this specific error
		Code *string `json:"code,omitempty"`

		// Field The field that caused the error
		Field string `json:"field"`

		// Message Description of what is wrong with the field
		Message string `json:"message"`
	} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter by brand(s). Comma-separated for OR matching.
	// Example: ?brand=Apple,Samsung
	Brand *[]string `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter by state(s). Comma-separated for OR matching.
	// Example: ?state=available,inactive
	State *[]ListDevicesParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Sort Fields to sort results by. Comma-separated for multi-field sorting.
	// Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	// Example: ?sort=-createdAt,name (sort by createdAt DESC, then name ASC)
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`

	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ListDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// ListDevicesParamsState defines parameters for ListDevices.
type ListDevicesParamsState string

// ListDevicesParamsAPIVersion defines parameters for ListDevices.
type ListDevicesParamsAPIVersion string

// HeadDevicesParams defines parameters for HeadDevices.
type HeadDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter by brand(s). Comma-separated for OR matching.
	// Example: ?brand=Apple,Samsung
	Brand *[]string `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter by state(s). Comma-separated for OR matching.
	// Example: ?state=available,inactive
	State *[]HeadDevicesParamsState `form:"state,omitempty" json:"state,omitempty"`

	// Sort Fields to sort results by. Comma-separated for multi-field sorting.
	// Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	// Example: ?sort=-createdAt,name (sort by createdAt DESC, then name ASC)
	Sort *[]string `form:"sort,omitempty" json:"sort,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadDevicesParamsState defines parameters for HeadDevices.
type HeadDevicesParamsState string

// HeadDevicesParamsAPIVersion defines parameters for HeadDevices.
type HeadDevicesParamsAPIVersion string

// CreateDeviceJSONBody defines parameters for CreateDevice.
type CreateDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State Initial state of the device (defaults to "available" if not provided)
	State *CreateDeviceJSONBodyState `json:"state,omitempty"`
}

// CreateDeviceParams defines parameters for CreateDevice.
type CreateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *CreateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IdempotencyKey Unique key to ensure idempotent POST requests.
	// If the same key is sent again within the TTL window (24 hours),
	// the server returns the cached response instead of creating a duplicate.
	//
	// **Requirements:**
	// - Must be a valid UUID v7
	// - Must be unique per logical operation
	// - Cached for 24 hours
	IdempotencyKey openapi_types.UUID `json:"Idempotency-Key"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// CreateDeviceParamsAPIVersion defines parameters for CreateDevice.
type CreateDeviceParamsAPIVersion string

// CreateDeviceJSONBodyState defines parameters for CreateDevice.
type CreateDeviceJSONBodyState string

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *DeleteDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`
}

// DeleteDeviceParamsAPIVersion defines parameters for DeleteDevice.
type DeleteDeviceParamsAPIVersion string

// GetDeviceParams defines parameters for GetDevice.
type GetDeviceParams struct {
	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *string `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *GetDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *string `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// GetDeviceParamsAPIVersion defines parameters for GetDevice.
type GetDeviceParamsAPIVersion string

// HeadDeviceParams defines parameters for HeadDevice.
type HeadDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadDeviceParamsAPIVersion defines parameters for HeadDevice.
type HeadDeviceParamsAPIVersion string

// PatchDeviceJSONBody defines parameters for PatchDevice.
type PatchDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The state of the device
	State *PatchDeviceJSONBodyState `json:"state,omitempty"`
}

// PatchDeviceParams defines parameters for PatchDevice.
type PatchDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *PatchDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// PatchDeviceParamsAPIVersion defines parameters for PatchDevice.
type PatchDeviceParamsAPIVersion string

// PatchDeviceJSONBodyState defines parameters for PatchDevice.
type PatchDeviceJSONBodyState string

// UpdateDeviceJSONBody defines parameters for UpdateDevice.
type UpdateDeviceJSONBody struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The state of the device
	State UpdateDeviceJSONBodyState `json:"state"`
}

// UpdateDeviceParams defines parameters for UpdateDevice.
type UpdateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization string `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *UpdateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *openapi_types.UUID `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *string `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *string `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *string `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *string `json:"Accept,omitempty"`
}

// UpdateDeviceParamsAPIVersion defines parameters for UpdateDevice.
type UpdateDeviceParamsAPIVersion string

// UpdateDeviceJSONBodyState defines parameters for UpdateDevice.
type UpdateDeviceJSONBodyState string

// CreateDeviceJSONRequestBody defines body for CreateDevice for application/json ContentType.
type CreateDeviceJSONRequestBody CreateDeviceJSONBody

// PatchDeviceJSONRequestBody defines body for PatchDevice for application/json ContentType.
type PatchDeviceJSONRequestBody PatchDeviceJSONBody

// UpdateDeviceJSONRequestBody defines body for UpdateDevice for application/json ContentType.
type UpdateDeviceJSONRequestBody UpdateDeviceJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all devices
	// (GET /devices)
	ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams)
	// Get devices collection metadata
	// (HEAD /devices)
	HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams)
	// Get allowed methods for devices collection
	// (OPTIONS /devices)
	OptionsDevices(w http.ResponseWriter, r *http.Request)
	// Create a new device
	// (POST /devices)
	CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams)
	// Delete a device
	// (DELETE /devices/{deviceId})
	DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params DeleteDeviceParams)
	// Get a device by ID
	// (GET /devices/{deviceId})
	GetDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params GetDeviceParams)
	// Get device metadata
	// (HEAD /devices/{deviceId})
	HeadDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params HeadDeviceParams)
	// Get allowed methods for device resource
	// (OPTIONS /devices/{deviceId})
	OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID)
	// Partially update a device
	// (PATCH /devices/{deviceId})
	PatchDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params PatchDeviceParams)
	// Fully update a device
	// (PUT /devices/{deviceId})
	UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params UpdateDeviceParams)
	// Health check
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// Liveness probe
	// (GET /liveness)
	LivenessCheck(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /readiness)
	ReadinessCheck(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List all devices
// (GET /devices)
func (_ Unimplemented) ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get devices collection metadata
// (HEAD /devices)
func (_ Unimplemented) HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for devices collection
// (OPTIONS /devices)
func (_ Unimplemented) OptionsDevices(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new device
// (POST /devices)
func (_ Unimplemented) CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a device
// (DELETE /devices/{deviceId})
func (_ Unimplemented) DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params DeleteDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a device by ID
// (GET /devices/{deviceId})
func (_ Unimplemented) GetDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params GetDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get device metadata
// (HEAD /devices/{deviceId})
func (_ Unimplemented) HeadDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params HeadDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for device resource
// (OPTIONS /devices/{deviceId})
func (_ Unimplemented) OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Partially update a device
// (PATCH /devices/{deviceId})
func (_ Unimplemented) PatchDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params PatchDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fully update a device
// (PUT /devices/{deviceId})
func (_ Unimplemented) UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId openapi_types.UUID, params UpdateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /liveness)
func (_ Unimplemented) LivenessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /readiness)
func (_ Unimplemented) ReadinessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", false, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ListDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevices operation middleware
func (siw *ServerInterfaceWrapper) HeadDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", false, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevices operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevices(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevices(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateDevice operation middleware
func (siw *ServerInterfaceWrapper) CreateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion CreateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Required header parameter "Idempotency-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Idempotency-Key")]; found {
		var IdempotencyKey openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Idempotency-Key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Idempotency-Key", valueList[0], &IdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Idempotency-Key", Err: err})
			return
		}

		params.IdempotencyKey = IdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter Idempotency-Key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Idempotency-Key", Err: err})
		return
	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDevice(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDevice operation middleware
func (siw *ServerInterfaceWrapper) DeleteDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion DeleteDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDevice operation middleware
func (siw *ServerInterfaceWrapper) GetDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDeviceParams

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion GetDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevice operation middleware
func (siw *ServerInterfaceWrapper) HeadDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevice operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevice(w, r, deviceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchDevice operation middleware
func (siw *ServerInterfaceWrapper) PatchDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion PatchDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateDevice operation middleware
func (siw *ServerInterfaceWrapper) UpdateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion UpdateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LivenessCheck operation middleware
func (siw *ServerInterfaceWrapper) LivenessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LivenessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadinessCheck operation middleware
func (siw *ServerInterfaceWrapper) ReadinessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadinessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices", wrapper.ListDevices)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices", wrapper.HeadDevices)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices", wrapper.OptionsDevices)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/devices", wrapper.CreateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/devices/{deviceId}", wrapper.DeleteDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices/{deviceId}", wrapper.GetDevice)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices/{deviceId}", wrapper.HeadDevice)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices/{deviceId}", wrapper.OptionsDevice)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/devices/{deviceId}", wrapper.PatchDevice)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/devices/{deviceId}", wrapper.UpdateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/liveness", wrapper.LivenessCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/readiness", wrapper.ReadinessCheck)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"yhlJ64XeSI7Pxz8BAAD///vnXwoa0wQA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
