// Package admin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package admin

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for CacheDependencyCheckStatus.
const (
	CacheDependencyCheckStatusDegraded CacheDependencyCheckStatus = "degraded"
	CacheDependencyCheckStatusDown     CacheDependencyCheckStatus = "down"
	CacheDependencyCheckStatusUnknown  CacheDependencyCheckStatus = "unknown"
	CacheDependencyCheckStatusUp       CacheDependencyCheckStatus = "up"
)

// Defines values for CacheHealthStatus.
const (
	Healthy     CacheHealthStatus = "healthy"
	Unavailable CacheHealthStatus = "unavailable"
	Unhealthy   CacheHealthStatus = "unhealthy"
)

// Defines values for DependencyCheckStatus.
const (
	DependencyCheckStatusDegraded DependencyCheckStatus = "degraded"
	DependencyCheckStatusDown     DependencyCheckStatus = "down"
	DependencyCheckStatusUnknown  DependencyCheckStatus = "unknown"
	DependencyCheckStatusUp       DependencyCheckStatus = "up"
)

// Defines values for DeviceState.
const (
	Available DeviceState = "available"
	InUse     DeviceState = "in-use"
	Inactive  DeviceState = "inactive"
)

// Defines values for HealthStatus.
const (
	HealthStatusDegraded    HealthStatus = "degraded"
	HealthStatusDown        HealthStatus = "down"
	HealthStatusMaintenance HealthStatus = "maintenance"
	HealthStatusOk          HealthStatus = "ok"
)

// Defines values for LivenessStatus.
const (
	LivenessStatusDegraded    LivenessStatus = "degraded"
	LivenessStatusDown        LivenessStatus = "down"
	LivenessStatusMaintenance LivenessStatus = "maintenance"
	LivenessStatusOk          LivenessStatus = "ok"
)

// Defines values for MetaApiVersion.
const (
	MetaApiVersionV1 MetaApiVersion = "v1"
)

// Defines values for ReadinessStatus.
const (
	Degraded    ReadinessStatus = "degraded"
	Down        ReadinessStatus = "down"
	Maintenance ReadinessStatus = "maintenance"
	Ok          ReadinessStatus = "ok"
)

// Defines values for ApiVersionHeader.
const (
	ApiVersionHeaderV1 ApiVersionHeader = "v1"
)

// CacheDependencyCheck defines model for CacheDependencyCheck.
type CacheDependencyCheck struct {
	// Details Cache-specific details
	Details *struct {
		// PoolStats Connection pool statistics
		PoolStats *PoolStats `json:"poolStats,omitempty"`

		// TotalKeys Total number of keys in the cache
		TotalKeys *int `json:"totalKeys,omitempty"`
	} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status CacheDependencyCheckStatus `json:"status"`
}

// CacheDependencyCheckStatus The status of the dependency
type CacheDependencyCheckStatus string

// CacheError Error response for cache operations
type CacheError struct {
	// Error Error message describing the failure
	Error string `json:"error"`
}

// CacheHealth Cache health status response
type CacheHealth struct {
	// Error Error message if cache is unavailable
	Error *string `json:"error,omitempty"`

	// Status Current health status of the cache
	Status CacheHealthStatus `json:"status"`
}

// CacheHealthStatus Current health status of the cache
type CacheHealthStatus string

// CachePatternPurge Response after purging cache entries by pattern
type CachePatternPurge struct {
	// Deleted Number of cache entries deleted
	Deleted int64 `json:"deleted"`

	// Pattern The pattern that was used for purging
	Pattern string `json:"pattern"`

	// Status Result message of the purge operation
	Status string `json:"status"`
}

// CachePurge Response after purging cache entries
type CachePurge struct {
	// Id Device ID that was purged (only for single device purge)
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Status Result message of the purge operation
	Status string `json:"status"`
}

// CreateDevice Request body for creating a new device
type CreateDevice struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State *DeviceState `json:"state,omitempty"`
}

// DependencyCheck Status of a single dependency
type DependencyCheck struct {
	// Details Additional dependency-specific details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status DependencyCheckStatus `json:"status"`
}

// DependencyCheckStatus The status of the dependency
type DependencyCheckStatus string

// Device A device resource
type Device struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// CreatedAt Timestamp when the device was created (immutable)
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique identifier for the device (UUID v7)
	Id openapi_types.UUID `json:"id"`

	// Links HATEOAS links for device navigation
	Links *DeviceLinks `json:"links,omitempty"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`

	// UpdatedAt Timestamp when the device was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// DeviceEnvelope Response envelope containing a single device with metadata
type DeviceEnvelope struct {
	// Data A device resource
	Data Device `json:"data"`

	// Meta Response metadata containing tracing information and API versioning.
	// All successful responses include this field to support observability and debugging.
	Meta Meta `json:"meta"`
}

// DeviceLinks HATEOAS links for device navigation
type DeviceLinks struct {
	// Self Link to this device resource
	Self *string `json:"self,omitempty"`
}

// DeviceState The current state of the device
type DeviceState string

// DevicesListEnvelope Response envelope containing a paginated list of devices with metadata
type DevicesListEnvelope struct {
	// Data List of devices
	Data []Device `json:"data"`

	// Meta Response metadata containing tracing information and API versioning.
	// All successful responses include this field to support observability and debugging.
	Meta Meta `json:"meta"`

	// Pagination Pagination metadata for list responses
	Pagination Pagination `json:"pagination"`
}

// Error Standard error response format
type Error struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]ErrorDetail `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ErrorDetail Detailed information about a specific error
type ErrorDetail struct {
	// Code Machine-readable error code for this specific error
	Code *string `json:"code,omitempty"`

	// Field The field that caused the error
	Field string `json:"field"`

	// Message Description of what is wrong with the field
	Message string `json:"message"`
}

// Health Comprehensive health check response with system metrics
type Health struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *CacheDependencyCheck `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage DependencyCheck `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices DependencyCheck `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall health status of the service
	Status HealthStatus `json:"status"`

	// System System resource information
	System *SystemInfo `json:"system,omitempty"`

	// Timestamp Timestamp of the health check
	Timestamp time.Time `json:"timestamp"`

	// Uptime Service uptime information
	Uptime UptimeInfo `json:"uptime"`

	// Version Version information about the service
	Version VersionInfo `json:"version"`
}

// HealthStatus The overall health status of the service
type HealthStatus string

// Liveness Liveness probe response
type Liveness struct {
	// Status The liveness status of the service
	Status LivenessStatus `json:"status"`

	// Timestamp Timestamp of the liveness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version string `json:"version"`
}

// LivenessStatus The liveness status of the service
type LivenessStatus string

// MemoryInfo Memory usage information
type MemoryInfo struct {
	// AllocMb Current memory allocation in MB
	AllocMb *float32 `json:"allocMb,omitempty"`

	// GcCycles Number of completed GC cycles
	GcCycles *int `json:"gcCycles,omitempty"`

	// SysMb Total memory obtained from the OS in MB
	SysMb *float32 `json:"sysMb,omitempty"`

	// TotalAllocMb Total memory allocated since start in MB
	TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
}

// Meta Response metadata containing tracing information and API versioning.
// All successful responses include this field to support observability and debugging.
type Meta struct {
	// ApiVersion API version used to process this request
	ApiVersion MetaApiVersion `json:"apiVersion"`

	// RequestId Unique identifier for this specific request.
	// Matches the `Request-Id` response header.
	// Use this for correlating logs and debugging.
	RequestId openapi_types.UUID `json:"requestId"`

	// TraceId W3C Trace Context trace ID extracted from the traceparent header.
	// Present only when distributed tracing is enabled.
	// Use this to trace requests across multiple services.
	TraceId *string `json:"traceId,omitempty"`
}

// MetaApiVersion API version used to process this request
type MetaApiVersion string

// Pagination Pagination metadata for list responses
type Pagination struct {
	// HasNext Whether there is a next page
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrevious Whether there is a previous page
	HasPrevious *bool `json:"hasPrevious,omitempty"`

	// Links HATEOAS links for pagination navigation
	Links *PaginationLinks `json:"links,omitempty"`

	// NextCursor Opaque cursor for fetching the next page using keyset pagination.
	// Only present when hasNext is true.
	NextCursor *string `json:"nextCursor,omitempty"`

	// Page Current page number (1-indexed)
	Page int `json:"page"`

	// PreviousCursor Opaque cursor for fetching the previous page using keyset pagination.
	// Only present when hasPrevious is true.
	PreviousCursor *string `json:"previousCursor,omitempty"`

	// Size Number of items per page
	Size int `json:"size"`

	// TotalItems Total number of items across all pages
	TotalItems int `json:"totalItems"`

	// TotalPages Total number of pages
	TotalPages int `json:"totalPages"`
}

// PaginationLinks HATEOAS links for pagination navigation
type PaginationLinks struct {
	// First Link to the first page
	First *string `json:"first,omitempty"`

	// Last Link to the last page
	Last *string `json:"last,omitempty"`

	// Next Link to the next page (null if on last page)
	Next *string `json:"next"`

	// Previous Link to the previous page (null if on first page)
	Previous *string `json:"previous"`

	// Self Link to the current page
	Self *string `json:"self,omitempty"`
}

// PatchDevice Request body for partially updating a device (PATCH)
type PatchDevice struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The current state of the device
	State *DeviceState `json:"state,omitempty"`
}

// PoolStats Connection pool statistics
type PoolStats struct {
	// Hits Number of successful pool hits
	Hits *int `json:"hits,omitempty"`

	// IdleConnections Number of idle connections in the pool
	IdleConnections *int `json:"idleConnections,omitempty"`

	// Misses Number of pool misses
	Misses *int `json:"misses,omitempty"`

	// StaleConnections Number of stale connections removed from the pool
	StaleConnections *int `json:"staleConnections,omitempty"`

	// Timeouts Number of connection timeouts
	Timeouts *int `json:"timeouts,omitempty"`

	// TotalConnections Total number of connections in the pool
	TotalConnections *int `json:"totalConnections,omitempty"`

	// WaitCount Number of times a connection was waited for
	WaitCount *int `json:"waitCount,omitempty"`

	// WaitDurationNs Total time spent waiting for connections in nanoseconds
	WaitDurationNs *int `json:"waitDurationNs,omitempty"`
}

// Readiness Readiness probe response with dependency status
type Readiness struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *CacheDependencyCheck `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage DependencyCheck `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices DependencyCheck `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall readiness status of the service
	Status ReadinessStatus `json:"status"`

	// Timestamp Timestamp of the readiness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version (optional)
	Version *string `json:"version,omitempty"`
}

// ReadinessStatus The overall readiness status of the service
type ReadinessStatus string

// SystemInfo System resource information
type SystemInfo struct {
	// CpuCores Number of CPU cores available
	CpuCores *int `json:"cpuCores,omitempty"`

	// Goroutines Number of active goroutines
	Goroutines *int `json:"goroutines,omitempty"`

	// Memory Memory usage information
	Memory *MemoryInfo `json:"memory,omitempty"`
}

// UpdateDevice Request body for fully updating a device (PUT)
type UpdateDevice struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`
}

// UptimeInfo Service uptime information
type UptimeInfo struct {
	// Duration Human-readable uptime duration
	Duration string `json:"duration"`

	// DurationSeconds Uptime in seconds
	DurationSeconds *int `json:"durationSeconds,omitempty"`

	// StartedAt Timestamp when the service started
	StartedAt time.Time `json:"startedAt"`
}

// VersionInfo Version information about the service
type VersionInfo struct {
	// Api API version
	Api string `json:"api"`

	// Build Build version or commit hash
	Build string `json:"build"`

	// Go Go runtime version
	Go *string `json:"go,omitempty"`
}

// AcceptEncodingHeader defines model for AcceptEncodingHeader.
type AcceptEncodingHeader = string

// AcceptHeader defines model for AcceptHeader.
type AcceptHeader = string

// ApiVersionHeader defines model for ApiVersionHeader.
type ApiVersionHeader string

// AuthorizationHeader defines model for AuthorizationHeader.
type AuthorizationHeader = string

// BrandFilterParam defines model for BrandFilterParam.
type BrandFilterParam = []string

// CachePatternParam defines model for CachePatternParam.
type CachePatternParam = string

// CursorParam defines model for CursorParam.
type CursorParam = string

// DeviceIdParam defines model for DeviceIdParam.
type DeviceIdParam = openapi_types.UUID

// FieldsParam defines model for FieldsParam.
type FieldsParam = string

// IdempotencyKeyHeader defines model for IdempotencyKeyHeader.
type IdempotencyKeyHeader = openapi_types.UUID

// IfMatchHeader defines model for IfMatchHeader.
type IfMatchHeader = string

// IfNoneMatchHeader defines model for IfNoneMatchHeader.
type IfNoneMatchHeader = string

// PageParam defines model for PageParam.
type PageParam = int

// RequestIdHeader defines model for RequestIdHeader.
type RequestIdHeader = openapi_types.UUID

// SearchParam defines model for SearchParam.
type SearchParam = string

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = []string

// StateFilterParam defines model for StateFilterParam.
type StateFilterParam = []DeviceState

// TraceparentHeader defines model for TraceparentHeader.
type TraceparentHeader = string

// TracestateHeader defines model for TracestateHeader.
type TracestateHeader = string

// BadRequest Standard error response format
type BadRequest = Error

// CacheBadRequest Error response for cache operations
type CacheBadRequest = CacheError

// CacheHealthOk Cache health status response
type CacheHealthOk = CacheHealth

// CacheHealthUnavailable Cache health status response
type CacheHealthUnavailable = CacheHealth

// CachePurgeAllDevices Response after purging cache entries
type CachePurgeAllDevices = CachePurge

// CachePurgeDevice Response after purging cache entries
type CachePurgeDevice = CachePurge

// CachePurgeLists Response after purging cache entries
type CachePurgeLists = CachePurge

// CachePurgePattern Response after purging cache entries by pattern
type CachePurgePattern = CachePatternPurge

// CacheServerError Error response for cache operations
type CacheServerError = CacheError

// CacheUnavailable Error response for cache operations
type CacheUnavailable = CacheError

// Conflict Standard error response format
type Conflict = Error

// DeviceCreated Response envelope containing a single device with metadata
type DeviceCreated = DeviceEnvelope

// DeviceRetrieved Response envelope containing a single device with metadata
type DeviceRetrieved = DeviceEnvelope

// DeviceUpdated Response envelope containing a single device with metadata
type DeviceUpdated = DeviceEnvelope

// DevicesList Response envelope containing a paginated list of devices with metadata
type DevicesList = DevicesListEnvelope

// HealthDown Comprehensive health check response with system metrics
type HealthDown = Health

// HealthOk Comprehensive health check response with system metrics
type HealthOk = Health

// LivenessDown Liveness probe response
type LivenessDown = Liveness

// LivenessOk Liveness probe response
type LivenessOk = Liveness

// NotAcceptable Standard error response format
type NotAcceptable = Error

// NotFound Standard error response format
type NotFound = Error

// PreconditionFailed Standard error response format
type PreconditionFailed = Error

// RateLimit Standard error response format
type RateLimit = Error

// ReadinessDown Readiness probe response with dependency status
type ReadinessDown = Readiness

// ReadinessOk Readiness probe response with dependency status
type ReadinessOk = Readiness

// ServerError Standard error response format
type ServerError = Error

// Unauthorized Standard error response format
type Unauthorized = Error

// UnprocessableEntity Standard error response format
type UnprocessableEntity = Error

// PurgeCacheByPatternParams defines parameters for PurgeCacheByPattern.
type PurgeCacheByPatternParams struct {
	// Pattern Glob-style pattern to match cache keys.
	// Examples: `device:*`, `devices:list:v1:*`
	Pattern CachePatternParam `form:"pattern" json:"pattern"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Purge all device caches
	// (DELETE /admin/cache/devices)
	PurgeAllDeviceCaches(w http.ResponseWriter, r *http.Request)
	// Purge all device list caches
	// (DELETE /admin/cache/devices/lists)
	PurgeDeviceListCaches(w http.ResponseWriter, r *http.Request)
	// Purge cache for a specific device
	// (DELETE /admin/cache/devices/{deviceId})
	PurgeDeviceCache(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam)
	// Check cache health status
	// (GET /admin/cache/health)
	GetCacheHealth(w http.ResponseWriter, r *http.Request)
	// Purge cache entries by pattern
	// (DELETE /admin/cache/pattern)
	PurgeCacheByPattern(w http.ResponseWriter, r *http.Request, params PurgeCacheByPatternParams)
	// Health check
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// Liveness probe
	// (GET /liveness)
	LivenessCheck(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /readiness)
	ReadinessCheck(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Purge all device caches
// (DELETE /admin/cache/devices)
func (_ Unimplemented) PurgeAllDeviceCaches(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Purge all device list caches
// (DELETE /admin/cache/devices/lists)
func (_ Unimplemented) PurgeDeviceListCaches(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Purge cache for a specific device
// (DELETE /admin/cache/devices/{deviceId})
func (_ Unimplemented) PurgeDeviceCache(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Check cache health status
// (GET /admin/cache/health)
func (_ Unimplemented) GetCacheHealth(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Purge cache entries by pattern
// (DELETE /admin/cache/pattern)
func (_ Unimplemented) PurgeCacheByPattern(w http.ResponseWriter, r *http.Request, params PurgeCacheByPatternParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /liveness)
func (_ Unimplemented) LivenessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /readiness)
func (_ Unimplemented) ReadinessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PurgeAllDeviceCaches operation middleware
func (siw *ServerInterfaceWrapper) PurgeAllDeviceCaches(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PurgeAllDeviceCaches(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PurgeDeviceListCaches operation middleware
func (siw *ServerInterfaceWrapper) PurgeDeviceListCaches(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PurgeDeviceListCaches(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PurgeDeviceCache operation middleware
func (siw *ServerInterfaceWrapper) PurgeDeviceCache(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PurgeDeviceCache(w, r, deviceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCacheHealth operation middleware
func (siw *ServerInterfaceWrapper) GetCacheHealth(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCacheHealth(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PurgeCacheByPattern operation middleware
func (siw *ServerInterfaceWrapper) PurgeCacheByPattern(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PurgeCacheByPatternParams

	// ------------- Required query parameter "pattern" -------------

	if paramValue := r.URL.Query().Get("pattern"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "pattern"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "pattern", r.URL.Query(), &params.Pattern)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pattern", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PurgeCacheByPattern(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LivenessCheck operation middleware
func (siw *ServerInterfaceWrapper) LivenessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LivenessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadinessCheck operation middleware
func (siw *ServerInterfaceWrapper) ReadinessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadinessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/admin/cache/devices", wrapper.PurgeAllDeviceCaches)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/admin/cache/devices/lists", wrapper.PurgeDeviceListCaches)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/admin/cache/devices/{deviceId}", wrapper.PurgeDeviceCache)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/admin/cache/health", wrapper.GetCacheHealth)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/admin/cache/pattern", wrapper.PurgeCacheByPattern)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/liveness", wrapper.LivenessCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/readiness", wrapper.ReadinessCheck)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
