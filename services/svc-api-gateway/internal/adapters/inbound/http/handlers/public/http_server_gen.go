// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	PasetoAuthScopes = "PasetoAuth.Scopes"
)

// Defines values for CacheDependencyCheckStatus.
const (
	CacheDependencyCheckStatusDegraded CacheDependencyCheckStatus = "degraded"
	CacheDependencyCheckStatusDown     CacheDependencyCheckStatus = "down"
	CacheDependencyCheckStatusUnknown  CacheDependencyCheckStatus = "unknown"
	CacheDependencyCheckStatusUp       CacheDependencyCheckStatus = "up"
)

// Defines values for CacheHealthStatus.
const (
	Healthy     CacheHealthStatus = "healthy"
	Unavailable CacheHealthStatus = "unavailable"
	Unhealthy   CacheHealthStatus = "unhealthy"
)

// Defines values for DependencyCheckStatus.
const (
	DependencyCheckStatusDegraded DependencyCheckStatus = "degraded"
	DependencyCheckStatusDown     DependencyCheckStatus = "down"
	DependencyCheckStatusUnknown  DependencyCheckStatus = "unknown"
	DependencyCheckStatusUp       DependencyCheckStatus = "up"
)

// Defines values for DeviceState.
const (
	Available DeviceState = "available"
	InUse     DeviceState = "in-use"
	Inactive  DeviceState = "inactive"
)

// Defines values for HealthStatus.
const (
	HealthStatusDegraded    HealthStatus = "degraded"
	HealthStatusDown        HealthStatus = "down"
	HealthStatusMaintenance HealthStatus = "maintenance"
	HealthStatusOk          HealthStatus = "ok"
)

// Defines values for LivenessStatus.
const (
	LivenessStatusDegraded    LivenessStatus = "degraded"
	LivenessStatusDown        LivenessStatus = "down"
	LivenessStatusMaintenance LivenessStatus = "maintenance"
	LivenessStatusOk          LivenessStatus = "ok"
)

// Defines values for MetaApiVersion.
const (
	MetaApiVersionV1 MetaApiVersion = "v1"
)

// Defines values for ReadinessStatus.
const (
	Degraded    ReadinessStatus = "degraded"
	Down        ReadinessStatus = "down"
	Maintenance ReadinessStatus = "maintenance"
	Ok          ReadinessStatus = "ok"
)

// Defines values for ApiVersionHeader.
const (
	ApiVersionHeaderV1 ApiVersionHeader = "v1"
)

// Defines values for ListDevicesParamsAPIVersion.
const (
	ListDevicesParamsAPIVersionV1 ListDevicesParamsAPIVersion = "v1"
)

// Defines values for HeadDevicesParamsAPIVersion.
const (
	HeadDevicesParamsAPIVersionV1 HeadDevicesParamsAPIVersion = "v1"
)

// Defines values for CreateDeviceParamsAPIVersion.
const (
	CreateDeviceParamsAPIVersionV1 CreateDeviceParamsAPIVersion = "v1"
)

// Defines values for DeleteDeviceParamsAPIVersion.
const (
	DeleteDeviceParamsAPIVersionV1 DeleteDeviceParamsAPIVersion = "v1"
)

// Defines values for GetDeviceParamsAPIVersion.
const (
	GetDeviceParamsAPIVersionV1 GetDeviceParamsAPIVersion = "v1"
)

// Defines values for HeadDeviceParamsAPIVersion.
const (
	HeadDeviceParamsAPIVersionV1 HeadDeviceParamsAPIVersion = "v1"
)

// Defines values for PatchDeviceParamsAPIVersion.
const (
	PatchDeviceParamsAPIVersionV1 PatchDeviceParamsAPIVersion = "v1"
)

// Defines values for UpdateDeviceParamsAPIVersion.
const (
	UpdateDeviceParamsAPIVersionV1 UpdateDeviceParamsAPIVersion = "v1"
)

// CacheDependencyCheck defines model for CacheDependencyCheck.
type CacheDependencyCheck struct {
	// Details Cache-specific details
	Details *struct {
		// PoolStats Connection pool statistics
		PoolStats *PoolStats `json:"poolStats,omitempty"`

		// TotalKeys Total number of keys in the cache
		TotalKeys *int `json:"totalKeys,omitempty"`
	} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status CacheDependencyCheckStatus `json:"status"`
}

// CacheDependencyCheckStatus The status of the dependency
type CacheDependencyCheckStatus string

// CacheError Error response for cache operations
type CacheError struct {
	// Error Error message describing the failure
	Error string `json:"error"`
}

// CacheHealth Cache health status response
type CacheHealth struct {
	// Error Error message if cache is unavailable
	Error *string `json:"error,omitempty"`

	// Status Current health status of the cache
	Status CacheHealthStatus `json:"status"`
}

// CacheHealthStatus Current health status of the cache
type CacheHealthStatus string

// CachePatternPurge Response after purging cache entries by pattern
type CachePatternPurge struct {
	// Deleted Number of cache entries deleted
	Deleted int64 `json:"deleted"`

	// Pattern The pattern that was used for purging
	Pattern string `json:"pattern"`

	// Status Result message of the purge operation
	Status string `json:"status"`
}

// CachePurge Response after purging cache entries
type CachePurge struct {
	// Id Device ID that was purged (only for single device purge)
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Status Result message of the purge operation
	Status string `json:"status"`
}

// CreateDevice Request body for creating a new device
type CreateDevice struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State *DeviceState `json:"state,omitempty"`
}

// DependencyCheck Status of a single dependency
type DependencyCheck struct {
	// Details Additional dependency-specific details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status DependencyCheckStatus `json:"status"`
}

// DependencyCheckStatus The status of the dependency
type DependencyCheckStatus string

// Device A device resource
type Device struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// CreatedAt Timestamp when the device was created (immutable)
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique identifier for the device (UUID v7)
	Id openapi_types.UUID `json:"id"`

	// Links HATEOAS links for device navigation
	Links *DeviceLinks `json:"links,omitempty"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`

	// UpdatedAt Timestamp when the device was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// DeviceEnvelope Response envelope containing a single device with metadata
type DeviceEnvelope struct {
	// Data A device resource
	Data Device `json:"data"`

	// Meta Response metadata containing tracing information and API versioning.
	// All successful responses include this field to support observability and debugging.
	Meta Meta `json:"meta"`
}

// DeviceLinks HATEOAS links for device navigation
type DeviceLinks struct {
	// Self Link to this device resource
	Self *string `json:"self,omitempty"`
}

// DeviceState The current state of the device
type DeviceState string

// DevicesListEnvelope Response envelope containing a paginated list of devices with metadata
type DevicesListEnvelope struct {
	// Data List of devices
	Data []Device `json:"data"`

	// Meta Response metadata containing tracing information and API versioning.
	// All successful responses include this field to support observability and debugging.
	Meta Meta `json:"meta"`

	// Pagination Pagination metadata for list responses
	Pagination Pagination `json:"pagination"`
}

// Error Standard error response format
type Error struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]ErrorDetail `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ErrorDetail Detailed information about a specific error
type ErrorDetail struct {
	// Code Machine-readable error code for this specific error
	Code *string `json:"code,omitempty"`

	// Field The field that caused the error
	Field string `json:"field"`

	// Message Description of what is wrong with the field
	Message string `json:"message"`
}

// Health Comprehensive health check response with system metrics
type Health struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *CacheDependencyCheck `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage DependencyCheck `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices DependencyCheck `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall health status of the service
	Status HealthStatus `json:"status"`

	// System System resource information
	System *SystemInfo `json:"system,omitempty"`

	// Timestamp Timestamp of the health check
	Timestamp time.Time `json:"timestamp"`

	// Uptime Service uptime information
	Uptime UptimeInfo `json:"uptime"`

	// Version Version information about the service
	Version VersionInfo `json:"version"`
}

// HealthStatus The overall health status of the service
type HealthStatus string

// Liveness Liveness probe response
type Liveness struct {
	// Status The liveness status of the service
	Status LivenessStatus `json:"status"`

	// Timestamp Timestamp of the liveness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version string `json:"version"`
}

// LivenessStatus The liveness status of the service
type LivenessStatus string

// MemoryInfo Memory usage information
type MemoryInfo struct {
	// AllocMb Current memory allocation in MB
	AllocMb *float32 `json:"allocMb,omitempty"`

	// GcCycles Number of completed GC cycles
	GcCycles *int `json:"gcCycles,omitempty"`

	// SysMb Total memory obtained from the OS in MB
	SysMb *float32 `json:"sysMb,omitempty"`

	// TotalAllocMb Total memory allocated since start in MB
	TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
}

// Meta Response metadata containing tracing information and API versioning.
// All successful responses include this field to support observability and debugging.
type Meta struct {
	// ApiVersion API version used to process this request
	ApiVersion MetaApiVersion `json:"apiVersion"`

	// RequestId Unique identifier for this specific request.
	// Matches the `Request-Id` response header.
	// Use this for correlating logs and debugging.
	RequestId openapi_types.UUID `json:"requestId"`

	// TraceId W3C Trace Context trace ID extracted from the traceparent header.
	// Present only when distributed tracing is enabled.
	// Use this to trace requests across multiple services.
	TraceId *string `json:"traceId,omitempty"`
}

// MetaApiVersion API version used to process this request
type MetaApiVersion string

// Pagination Pagination metadata for list responses
type Pagination struct {
	// HasNext Whether there is a next page
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrevious Whether there is a previous page
	HasPrevious *bool `json:"hasPrevious,omitempty"`

	// Links HATEOAS links for pagination navigation
	Links *PaginationLinks `json:"links,omitempty"`

	// NextCursor Opaque cursor for fetching the next page using keyset pagination.
	// Only present when hasNext is true.
	NextCursor *string `json:"nextCursor,omitempty"`

	// Page Current page number (1-indexed)
	Page int `json:"page"`

	// PreviousCursor Opaque cursor for fetching the previous page using keyset pagination.
	// Only present when hasPrevious is true.
	PreviousCursor *string `json:"previousCursor,omitempty"`

	// Size Number of items per page
	Size int `json:"size"`

	// TotalItems Total number of items across all pages
	TotalItems int `json:"totalItems"`

	// TotalPages Total number of pages
	TotalPages int `json:"totalPages"`
}

// PaginationLinks HATEOAS links for pagination navigation
type PaginationLinks struct {
	// First Link to the first page
	First *string `json:"first,omitempty"`

	// Last Link to the last page
	Last *string `json:"last,omitempty"`

	// Next Link to the next page (null if on last page)
	Next *string `json:"next"`

	// Previous Link to the previous page (null if on first page)
	Previous *string `json:"previous"`

	// Self Link to the current page
	Self *string `json:"self,omitempty"`
}

// PatchDevice Request body for partially updating a device (PATCH)
type PatchDevice struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The current state of the device
	State *DeviceState `json:"state,omitempty"`
}

// PoolStats Connection pool statistics
type PoolStats struct {
	// Hits Number of successful pool hits
	Hits *int `json:"hits,omitempty"`

	// IdleConnections Number of idle connections in the pool
	IdleConnections *int `json:"idleConnections,omitempty"`

	// Misses Number of pool misses
	Misses *int `json:"misses,omitempty"`

	// StaleConnections Number of stale connections removed from the pool
	StaleConnections *int `json:"staleConnections,omitempty"`

	// Timeouts Number of connection timeouts
	Timeouts *int `json:"timeouts,omitempty"`

	// TotalConnections Total number of connections in the pool
	TotalConnections *int `json:"totalConnections,omitempty"`

	// WaitCount Number of times a connection was waited for
	WaitCount *int `json:"waitCount,omitempty"`

	// WaitDurationNs Total time spent waiting for connections in nanoseconds
	WaitDurationNs *int `json:"waitDurationNs,omitempty"`
}

// Readiness Readiness probe response with dependency status
type Readiness struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *CacheDependencyCheck `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage DependencyCheck `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices DependencyCheck `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall readiness status of the service
	Status ReadinessStatus `json:"status"`

	// Timestamp Timestamp of the readiness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version (optional)
	Version *string `json:"version,omitempty"`
}

// ReadinessStatus The overall readiness status of the service
type ReadinessStatus string

// SystemInfo System resource information
type SystemInfo struct {
	// CpuCores Number of CPU cores available
	CpuCores *int `json:"cpuCores,omitempty"`

	// Goroutines Number of active goroutines
	Goroutines *int `json:"goroutines,omitempty"`

	// Memory Memory usage information
	Memory *MemoryInfo `json:"memory,omitempty"`
}

// UpdateDevice Request body for fully updating a device (PUT)
type UpdateDevice struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`
}

// UptimeInfo Service uptime information
type UptimeInfo struct {
	// Duration Human-readable uptime duration
	Duration string `json:"duration"`

	// DurationSeconds Uptime in seconds
	DurationSeconds *int `json:"durationSeconds,omitempty"`

	// StartedAt Timestamp when the service started
	StartedAt time.Time `json:"startedAt"`
}

// VersionInfo Version information about the service
type VersionInfo struct {
	// Api API version
	Api string `json:"api"`

	// Build Build version or commit hash
	Build string `json:"build"`

	// Go Go runtime version
	Go *string `json:"go,omitempty"`
}

// AcceptEncodingHeader defines model for AcceptEncodingHeader.
type AcceptEncodingHeader = string

// AcceptHeader defines model for AcceptHeader.
type AcceptHeader = string

// ApiVersionHeader defines model for ApiVersionHeader.
type ApiVersionHeader string

// AuthorizationHeader defines model for AuthorizationHeader.
type AuthorizationHeader = string

// BrandFilterParam defines model for BrandFilterParam.
type BrandFilterParam = []string

// CachePatternParam defines model for CachePatternParam.
type CachePatternParam = string

// CursorParam defines model for CursorParam.
type CursorParam = string

// DeviceIdParam defines model for DeviceIdParam.
type DeviceIdParam = openapi_types.UUID

// FieldsParam defines model for FieldsParam.
type FieldsParam = string

// IdempotencyKeyHeader defines model for IdempotencyKeyHeader.
type IdempotencyKeyHeader = openapi_types.UUID

// IfMatchHeader defines model for IfMatchHeader.
type IfMatchHeader = string

// IfNoneMatchHeader defines model for IfNoneMatchHeader.
type IfNoneMatchHeader = string

// PageParam defines model for PageParam.
type PageParam = int

// RequestIdHeader defines model for RequestIdHeader.
type RequestIdHeader = openapi_types.UUID

// SearchParam defines model for SearchParam.
type SearchParam = string

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = []string

// StateFilterParam defines model for StateFilterParam.
type StateFilterParam = []DeviceState

// TraceparentHeader defines model for TraceparentHeader.
type TraceparentHeader = string

// TracestateHeader defines model for TracestateHeader.
type TracestateHeader = string

// BadRequest Standard error response format
type BadRequest = Error

// CacheBadRequest Error response for cache operations
type CacheBadRequest = CacheError

// CacheHealthOk Cache health status response
type CacheHealthOk = CacheHealth

// CacheHealthUnavailable Cache health status response
type CacheHealthUnavailable = CacheHealth

// CachePurgeAllDevices Response after purging cache entries
type CachePurgeAllDevices = CachePurge

// CachePurgeDevice Response after purging cache entries
type CachePurgeDevice = CachePurge

// CachePurgeLists Response after purging cache entries
type CachePurgeLists = CachePurge

// CachePurgePattern Response after purging cache entries by pattern
type CachePurgePattern = CachePatternPurge

// CacheServerError Error response for cache operations
type CacheServerError = CacheError

// CacheUnavailable Error response for cache operations
type CacheUnavailable = CacheError

// Conflict Standard error response format
type Conflict = Error

// DeviceCreated Response envelope containing a single device with metadata
type DeviceCreated = DeviceEnvelope

// DeviceRetrieved Response envelope containing a single device with metadata
type DeviceRetrieved = DeviceEnvelope

// DeviceUpdated Response envelope containing a single device with metadata
type DeviceUpdated = DeviceEnvelope

// DevicesList Response envelope containing a paginated list of devices with metadata
type DevicesList = DevicesListEnvelope

// HealthDown Comprehensive health check response with system metrics
type HealthDown = Health

// HealthOk Comprehensive health check response with system metrics
type HealthOk = Health

// LivenessDown Liveness probe response
type LivenessDown = Liveness

// LivenessOk Liveness probe response
type LivenessOk = Liveness

// NotAcceptable Standard error response format
type NotAcceptable = Error

// NotFound Standard error response format
type NotFound = Error

// PreconditionFailed Standard error response format
type PreconditionFailed = Error

// RateLimit Standard error response format
type RateLimit = Error

// ReadinessDown Readiness probe response with dependency status
type ReadinessDown = Readiness

// ReadinessOk Readiness probe response with dependency status
type ReadinessOk = Readiness

// ServerError Standard error response format
type ServerError = Error

// Unauthorized Standard error response format
type Unauthorized = Error

// UnprocessableEntity Standard error response format
type UnprocessableEntity = Error

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter by brand(s). Comma-separated for OR matching.
	// Example: ?brand=Apple,Samsung
	Brand *BrandFilterParam `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter by state(s). Comma-separated for OR matching.
	// Example: ?state=available,inactive
	State *StateFilterParam `form:"state,omitempty" json:"state,omitempty"`

	// Sort Fields to sort results by. Comma-separated for multi-field sorting.
	// Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	// Example: ?sort=-createdAt,name (sort by createdAt DESC, then name ASC)
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Q Full-text search query across name and brand fields.
	// Uses PostgreSQL full-text search with English language stemming.
	//
	// **Features:**
	// - Matches word variations (e.g., "running" matches "run")
	// - Case-insensitive search
	// - Searches both name and brand fields
	//
	// **Examples:**
	// - `?q=iPhone` - matches "iPhone 15 Pro", "My iPhone", etc.
	// - `?q=Samsung` - matches devices with Samsung brand
	// - `?q=Galaxy` - matches "Galaxy S24", "Galaxy Tab", etc.
	//
	// **Combining with filters:**
	// - `?q=iPhone&state=available` - available iPhones only
	// - `?q=Pro&brand=Apple` - Apple devices with "Pro" in name
	Q *SearchParam `form:"q,omitempty" json:"q,omitempty"`

	// Cursor Opaque cursor for keyset-based pagination.
	// When provided, the `page` parameter is ignored.
	//
	// **Usage:**
	// 1. First request: Don't include cursor (uses page-based pagination)
	// 2. Subsequent requests: Use `pagination.nextCursor` or `pagination.previousCursor` from previous response
	//
	// **Benefits over offset pagination:**
	// - Stable results even when data changes between requests
	// - Better performance for large datasets (no OFFSET scanning)
	// - Consistent page sizes
	//
	// **Note:** Cursors are opaque strings - do not parse or modify them.
	Cursor *CursorParam `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *FieldsParam `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ListDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *IfNoneMatchHeader `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *AcceptEncodingHeader `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`
}

// ListDevicesParamsAPIVersion defines parameters for ListDevices.
type ListDevicesParamsAPIVersion string

// HeadDevicesParams defines parameters for HeadDevices.
type HeadDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter by brand(s). Comma-separated for OR matching.
	// Example: ?brand=Apple,Samsung
	Brand *BrandFilterParam `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter by state(s). Comma-separated for OR matching.
	// Example: ?state=available,inactive
	State *StateFilterParam `form:"state,omitempty" json:"state,omitempty"`

	// Sort Fields to sort results by. Comma-separated for multi-field sorting.
	// Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	// Example: ?sort=-createdAt,name (sort by createdAt DESC, then name ASC)
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Q Full-text search query across name and brand fields.
	// Uses PostgreSQL full-text search with English language stemming.
	//
	// **Features:**
	// - Matches word variations (e.g., "running" matches "run")
	// - Case-insensitive search
	// - Searches both name and brand fields
	//
	// **Examples:**
	// - `?q=iPhone` - matches "iPhone 15 Pro", "My iPhone", etc.
	// - `?q=Samsung` - matches devices with Samsung brand
	// - `?q=Galaxy` - matches "Galaxy S24", "Galaxy Tab", etc.
	//
	// **Combining with filters:**
	// - `?q=iPhone&state=available` - available iPhones only
	// - `?q=Pro&brand=Apple` - Apple devices with "Pro" in name
	Q *SearchParam `form:"q,omitempty" json:"q,omitempty"`

	// Cursor Opaque cursor for keyset-based pagination.
	// When provided, the `page` parameter is ignored.
	//
	// **Usage:**
	// 1. First request: Don't include cursor (uses page-based pagination)
	// 2. Subsequent requests: Use `pagination.nextCursor` or `pagination.previousCursor` from previous response
	//
	// **Benefits over offset pagination:**
	// - Stable results even when data changes between requests
	// - Better performance for large datasets (no OFFSET scanning)
	// - Consistent page sizes
	//
	// **Note:** Cursors are opaque strings - do not parse or modify them.
	Cursor *CursorParam `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDevicesParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *IfNoneMatchHeader `json:"If-None-Match,omitempty"`
}

// HeadDevicesParamsAPIVersion defines parameters for HeadDevices.
type HeadDevicesParamsAPIVersion string

// CreateDeviceParams defines parameters for CreateDevice.
type CreateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *CreateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`

	// IdempotencyKey Unique key to ensure idempotent POST requests.
	// If the same key is sent again within the TTL window (24 hours),
	// the server returns the cached response instead of creating a duplicate.
	//
	// **Requirements:**
	// - Must be a valid UUID v7
	// - Must be unique per logical operation
	// - Cached for 24 hours
	IdempotencyKey IdempotencyKeyHeader `json:"Idempotency-Key"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`
}

// CreateDeviceParamsAPIVersion defines parameters for CreateDevice.
type CreateDeviceParamsAPIVersion string

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *DeleteDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// DeleteDeviceParamsAPIVersion defines parameters for DeleteDevice.
type DeleteDeviceParamsAPIVersion string

// GetDeviceParams defines parameters for GetDevice.
type GetDeviceParams struct {
	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *FieldsParam `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *GetDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *IfNoneMatchHeader `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *AcceptEncodingHeader `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`
}

// GetDeviceParamsAPIVersion defines parameters for GetDevice.
type GetDeviceParamsAPIVersion string

// HeadDeviceParams defines parameters for HeadDevice.
type HeadDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *HeadDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *IfNoneMatchHeader `json:"If-None-Match,omitempty"`
}

// HeadDeviceParamsAPIVersion defines parameters for HeadDevice.
type HeadDeviceParamsAPIVersion string

// PatchDeviceParams defines parameters for PatchDevice.
type PatchDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *PatchDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *IfMatchHeader `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`
}

// PatchDeviceParamsAPIVersion defines parameters for PatchDevice.
type PatchDeviceParamsAPIVersion string

// UpdateDeviceParams defines parameters for UpdateDevice.
type UpdateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *UpdateDeviceParamsAPIVersion `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *IfMatchHeader `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`
}

// UpdateDeviceParamsAPIVersion defines parameters for UpdateDevice.
type UpdateDeviceParamsAPIVersion string

// CreateDeviceJSONRequestBody defines body for CreateDevice for application/json ContentType.
type CreateDeviceJSONRequestBody = CreateDevice

// PatchDeviceJSONRequestBody defines body for PatchDevice for application/json ContentType.
type PatchDeviceJSONRequestBody = PatchDevice

// UpdateDeviceJSONRequestBody defines body for UpdateDevice for application/json ContentType.
type UpdateDeviceJSONRequestBody = UpdateDevice

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all devices
	// (GET /devices)
	ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams)
	// Get devices collection metadata
	// (HEAD /devices)
	HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams)
	// Get allowed methods for devices collection
	// (OPTIONS /devices)
	OptionsDevices(w http.ResponseWriter, r *http.Request)
	// Create a new device
	// (POST /devices)
	CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams)
	// Delete a device
	// (DELETE /devices/{deviceId})
	DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params DeleteDeviceParams)
	// Get a device by ID
	// (GET /devices/{deviceId})
	GetDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params GetDeviceParams)
	// Get device metadata
	// (HEAD /devices/{deviceId})
	HeadDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params HeadDeviceParams)
	// Get allowed methods for device resource
	// (OPTIONS /devices/{deviceId})
	OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam)
	// Partially update a device
	// (PATCH /devices/{deviceId})
	PatchDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params PatchDeviceParams)
	// Fully update a device
	// (PUT /devices/{deviceId})
	UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params UpdateDeviceParams)
	// Health check
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// Liveness probe
	// (GET /liveness)
	LivenessCheck(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /readiness)
	ReadinessCheck(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List all devices
// (GET /devices)
func (_ Unimplemented) ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get devices collection metadata
// (HEAD /devices)
func (_ Unimplemented) HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for devices collection
// (OPTIONS /devices)
func (_ Unimplemented) OptionsDevices(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new device
// (POST /devices)
func (_ Unimplemented) CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a device
// (DELETE /devices/{deviceId})
func (_ Unimplemented) DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params DeleteDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a device by ID
// (GET /devices/{deviceId})
func (_ Unimplemented) GetDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params GetDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get device metadata
// (HEAD /devices/{deviceId})
func (_ Unimplemented) HeadDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params HeadDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for device resource
// (OPTIONS /devices/{deviceId})
func (_ Unimplemented) OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Partially update a device
// (PATCH /devices/{deviceId})
func (_ Unimplemented) PatchDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params PatchDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fully update a device
// (PUT /devices/{deviceId})
func (_ Unimplemented) UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params UpdateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /liveness)
func (_ Unimplemented) LivenessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /readiness)
func (_ Unimplemented) ReadinessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", false, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ListDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding AcceptEncodingHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevices operation middleware
func (siw *ServerInterfaceWrapper) HeadDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", false, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDevicesParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevices operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevices(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevices(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateDevice operation middleware
func (siw *ServerInterfaceWrapper) CreateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion CreateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Required header parameter "Idempotency-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Idempotency-Key")]; found {
		var IdempotencyKey IdempotencyKeyHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Idempotency-Key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Idempotency-Key", valueList[0], &IdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Idempotency-Key", Err: err})
			return
		}

		params.IdempotencyKey = IdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter Idempotency-Key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Idempotency-Key", Err: err})
		return
	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDevice(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDevice operation middleware
func (siw *ServerInterfaceWrapper) DeleteDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion DeleteDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDevice operation middleware
func (siw *ServerInterfaceWrapper) GetDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDeviceParams

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion GetDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding AcceptEncodingHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevice operation middleware
func (siw *ServerInterfaceWrapper) HeadDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion HeadDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevice operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevice(w, r, deviceId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchDevice operation middleware
func (siw *ServerInterfaceWrapper) PatchDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion PatchDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateDevice operation middleware
func (siw *ServerInterfaceWrapper) UpdateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion UpdateDeviceParamsAPIVersion
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LivenessCheck operation middleware
func (siw *ServerInterfaceWrapper) LivenessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LivenessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadinessCheck operation middleware
func (siw *ServerInterfaceWrapper) ReadinessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadinessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices", wrapper.ListDevices)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices", wrapper.HeadDevices)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices", wrapper.OptionsDevices)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/devices", wrapper.CreateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/devices/{deviceId}", wrapper.DeleteDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices/{deviceId}", wrapper.GetDevice)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices/{deviceId}", wrapper.HeadDevice)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices/{deviceId}", wrapper.OptionsDevice)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/devices/{deviceId}", wrapper.PatchDevice)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/devices/{deviceId}", wrapper.UpdateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/liveness", wrapper.LivenessCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/readiness", wrapper.ReadinessCheck)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"///3WbsZsSABAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
