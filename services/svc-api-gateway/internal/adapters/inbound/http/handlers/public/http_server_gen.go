// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	PasetoAuthScopes = "PasetoAuth.Scopes"
)

// Defines values for CacheDependencyCheckStatus.
const (
	CacheDependencyCheckStatusDegraded CacheDependencyCheckStatus = "degraded"
	CacheDependencyCheckStatusDown     CacheDependencyCheckStatus = "down"
	CacheDependencyCheckStatusUnknown  CacheDependencyCheckStatus = "unknown"
	CacheDependencyCheckStatusUp       CacheDependencyCheckStatus = "up"
)

// Defines values for CacheHealthStatus.
const (
	Healthy     CacheHealthStatus = "healthy"
	Unavailable CacheHealthStatus = "unavailable"
	Unhealthy   CacheHealthStatus = "unhealthy"
)

// Defines values for DependencyCheckStatus.
const (
	DependencyCheckStatusDegraded DependencyCheckStatus = "degraded"
	DependencyCheckStatusDown     DependencyCheckStatus = "down"
	DependencyCheckStatusUnknown  DependencyCheckStatus = "unknown"
	DependencyCheckStatusUp       DependencyCheckStatus = "up"
)

// Defines values for DeviceState.
const (
	Available DeviceState = "available"
	InUse     DeviceState = "in-use"
	Inactive  DeviceState = "inactive"
)

// Defines values for HealthStatus.
const (
	HealthStatusDegraded    HealthStatus = "degraded"
	HealthStatusDown        HealthStatus = "down"
	HealthStatusMaintenance HealthStatus = "maintenance"
	HealthStatusOk          HealthStatus = "ok"
)

// Defines values for LivenessStatus.
const (
	LivenessStatusDegraded    LivenessStatus = "degraded"
	LivenessStatusDown        LivenessStatus = "down"
	LivenessStatusMaintenance LivenessStatus = "maintenance"
	LivenessStatusOk          LivenessStatus = "ok"
)

// Defines values for MetaApiVersion.
const (
	MetaApiVersionV1 MetaApiVersion = "v1"
)

// Defines values for ReadinessStatus.
const (
	Degraded    ReadinessStatus = "degraded"
	Down        ReadinessStatus = "down"
	Maintenance ReadinessStatus = "maintenance"
	Ok          ReadinessStatus = "ok"
)

// Defines values for ApiVersionHeader.
const (
	ApiVersionHeaderV1 ApiVersionHeader = "v1"
)

// CacheDependencyCheck defines model for CacheDependencyCheck.
type CacheDependencyCheck struct {
	// Details Cache-specific details
	Details *struct {
		// PoolStats Connection pool statistics
		PoolStats *PoolStats `json:"poolStats,omitempty"`

		// TotalKeys Total number of keys in the cache
		TotalKeys *int `json:"totalKeys,omitempty"`
	} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status CacheDependencyCheckStatus `json:"status"`
}

// CacheDependencyCheckStatus The status of the dependency
type CacheDependencyCheckStatus string

// CacheError Error response for cache operations
type CacheError struct {
	// Error Error message describing the failure
	Error string `json:"error"`
}

// CacheHealth Cache health status response
type CacheHealth struct {
	// Error Error message if cache is unavailable
	Error *string `json:"error,omitempty"`

	// Status Current health status of the cache
	Status CacheHealthStatus `json:"status"`
}

// CacheHealthStatus Current health status of the cache
type CacheHealthStatus string

// CachePatternPurge Response after purging cache entries by pattern
type CachePatternPurge struct {
	// Deleted Number of cache entries deleted
	Deleted int64 `json:"deleted"`

	// Pattern The pattern that was used for purging
	Pattern string `json:"pattern"`

	// Status Result message of the purge operation
	Status string `json:"status"`
}

// CachePurge Response after purging cache entries
type CachePurge struct {
	// Id Device ID that was purged (only for single device purge)
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Status Result message of the purge operation
	Status string `json:"status"`
}

// CreateDevice Request body for creating a new device
type CreateDevice struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State *DeviceState `json:"state,omitempty"`
}

// DependencyCheck Status of a single dependency
type DependencyCheck struct {
	// Details Additional dependency-specific details
	Details *map[string]interface{} `json:"details,omitempty"`

	// Error Error message if the dependency is unhealthy
	Error *string `json:"error,omitempty"`

	// LastChecked Timestamp of the last health check for this dependency
	LastChecked *time.Time `json:"lastChecked,omitempty"`

	// LatencyMs Latency of the last health check in milliseconds
	LatencyMs *int `json:"latencyMs,omitempty"`

	// Message Additional information about the dependency status
	Message *string `json:"message,omitempty"`

	// Status The status of the dependency
	Status DependencyCheckStatus `json:"status"`
}

// DependencyCheckStatus The status of the dependency
type DependencyCheckStatus string

// Device A device resource
type Device struct {
	// Brand The brand/manufacturer of the device
	Brand string `json:"brand"`

	// CreatedAt Timestamp when the device was created (immutable)
	CreatedAt time.Time `json:"createdAt"`

	// Id Unique identifier for the device (UUID v7)
	Id openapi_types.UUID `json:"id"`

	// Links HATEOAS links for device navigation
	Links *DeviceLinks `json:"links,omitempty"`

	// Name The name of the device
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`

	// UpdatedAt Timestamp when the device was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
}

// DeviceEnvelope Response envelope containing a single device with metadata
type DeviceEnvelope struct {
	// Data A device resource
	Data Device `json:"data"`

	// Meta Response metadata containing tracing information and API versioning.
	// All successful responses include this field to support observability and debugging.
	Meta Meta `json:"meta"`
}

// DeviceLinks HATEOAS links for device navigation
type DeviceLinks struct {
	// Self Link to this device resource
	Self *string `json:"self,omitempty"`
}

// DeviceState The current state of the device
type DeviceState string

// DevicesListEnvelope Response envelope containing a paginated list of devices with metadata
type DevicesListEnvelope struct {
	// Data List of devices
	Data []Device `json:"data"`

	// Meta Response metadata containing tracing information and API versioning.
	// All successful responses include this field to support observability and debugging.
	Meta Meta `json:"meta"`

	// Pagination Pagination metadata for list responses
	Pagination Pagination `json:"pagination"`
}

// Error Standard error response format
type Error struct {
	// Code Machine-readable error code
	Code string `json:"code"`

	// Details Additional error details for validation errors
	Details *[]ErrorDetail `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`

	// RequestId Unique request identifier for tracing
	RequestId openapi_types.UUID `json:"requestId"`

	// Timestamp Timestamp when the error occurred
	Timestamp time.Time `json:"timestamp"`

	// TraceId W3C Trace Context trace ID for distributed tracing (from traceparent header)
	TraceId *string `json:"traceId,omitempty"`
}

// ErrorDetail Detailed information about a specific error
type ErrorDetail struct {
	// Code Machine-readable error code for this specific error
	Code *string `json:"code,omitempty"`

	// Field The field that caused the error
	Field string `json:"field"`

	// Message Description of what is wrong with the field
	Message string `json:"message"`
}

// Health Comprehensive health check response with system metrics
type Health struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *CacheDependencyCheck `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage DependencyCheck `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices DependencyCheck `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall health status of the service
	Status HealthStatus `json:"status"`

	// System System resource information
	System *SystemInfo `json:"system,omitempty"`

	// Timestamp Timestamp of the health check
	Timestamp time.Time `json:"timestamp"`

	// Uptime Service uptime information
	Uptime UptimeInfo `json:"uptime"`

	// Version Version information about the service
	Version VersionInfo `json:"version"`
}

// HealthStatus The overall health status of the service
type HealthStatus string

// Liveness Liveness probe response
type Liveness struct {
	// Status The liveness status of the service
	Status LivenessStatus `json:"status"`

	// Timestamp Timestamp of the liveness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version
	Version string `json:"version"`
}

// LivenessStatus The liveness status of the service
type LivenessStatus string

// MemoryInfo Memory usage information
type MemoryInfo struct {
	// AllocMb Current memory allocation in MB
	AllocMb *float32 `json:"allocMb,omitempty"`

	// GcCycles Number of completed GC cycles
	GcCycles *int `json:"gcCycles,omitempty"`

	// SysMb Total memory obtained from the OS in MB
	SysMb *float32 `json:"sysMb,omitempty"`

	// TotalAllocMb Total memory allocated since start in MB
	TotalAllocMb *float32 `json:"totalAllocMb,omitempty"`
}

// Meta Response metadata containing tracing information and API versioning.
// All successful responses include this field to support observability and debugging.
type Meta struct {
	// ApiVersion API version used to process this request
	ApiVersion MetaApiVersion `json:"apiVersion"`

	// RequestId Unique identifier for this specific request.
	// Matches the `Request-Id` response header.
	// Use this for correlating logs and debugging.
	RequestId openapi_types.UUID `json:"requestId"`

	// TraceId W3C Trace Context trace ID extracted from the traceparent header.
	// Present only when distributed tracing is enabled.
	// Use this to trace requests across multiple services.
	TraceId *string `json:"traceId,omitempty"`
}

// MetaApiVersion API version used to process this request
type MetaApiVersion string

// Pagination Pagination metadata for list responses
type Pagination struct {
	// HasNext Whether there is a next page
	HasNext *bool `json:"hasNext,omitempty"`

	// HasPrevious Whether there is a previous page
	HasPrevious *bool `json:"hasPrevious,omitempty"`

	// Links HATEOAS links for pagination navigation
	Links *PaginationLinks `json:"links,omitempty"`

	// NextCursor Opaque cursor for fetching the next page using keyset pagination.
	// Only present when hasNext is true.
	NextCursor *string `json:"nextCursor,omitempty"`

	// Page Current page number (1-indexed)
	Page int `json:"page"`

	// PreviousCursor Opaque cursor for fetching the previous page using keyset pagination.
	// Only present when hasPrevious is true.
	PreviousCursor *string `json:"previousCursor,omitempty"`

	// Size Number of items per page
	Size int `json:"size"`

	// TotalItems Total number of items across all pages
	TotalItems int `json:"totalItems"`

	// TotalPages Total number of pages
	TotalPages int `json:"totalPages"`
}

// PaginationLinks HATEOAS links for pagination navigation
type PaginationLinks struct {
	// First Link to the first page
	First *string `json:"first,omitempty"`

	// Last Link to the last page
	Last *string `json:"last,omitempty"`

	// Next Link to the next page (null if on last page)
	Next *string `json:"next"`

	// Previous Link to the previous page (null if on first page)
	Previous *string `json:"previous"`

	// Self Link to the current page
	Self *string `json:"self,omitempty"`
}

// PatchDevice Request body for partially updating a device (PATCH)
type PatchDevice struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand *string `json:"brand,omitempty"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name *string `json:"name,omitempty"`

	// State The current state of the device
	State *DeviceState `json:"state,omitempty"`
}

// PoolStats Connection pool statistics
type PoolStats struct {
	// Hits Number of successful pool hits
	Hits *int `json:"hits,omitempty"`

	// IdleConnections Number of idle connections in the pool
	IdleConnections *int `json:"idleConnections,omitempty"`

	// Misses Number of pool misses
	Misses *int `json:"misses,omitempty"`

	// StaleConnections Number of stale connections removed from the pool
	StaleConnections *int `json:"staleConnections,omitempty"`

	// Timeouts Number of connection timeouts
	Timeouts *int `json:"timeouts,omitempty"`

	// TotalConnections Total number of connections in the pool
	TotalConnections *int `json:"totalConnections,omitempty"`

	// WaitCount Number of times a connection was waited for
	WaitCount *int `json:"waitCount,omitempty"`

	// WaitDurationNs Total time spent waiting for connections in nanoseconds
	WaitDurationNs *int `json:"waitDurationNs,omitempty"`
}

// Readiness Readiness probe response with dependency status
type Readiness struct {
	// Checks Status of individual dependency checks grouped by category
	Checks struct {
		// Infra Infrastructure dependencies (storage, cache, etc.)
		Infra struct {
			Cache *CacheDependencyCheck `json:"cache,omitempty"`

			// Storage Status of a single dependency
			Storage DependencyCheck `json:"storage"`
		} `json:"infra"`

		// Services Service dependencies (downstream services)
		Services struct {
			// Devices Status of a single dependency
			Devices DependencyCheck `json:"devices"`
		} `json:"services"`
	} `json:"checks"`

	// Status The overall readiness status of the service
	Status ReadinessStatus `json:"status"`

	// Timestamp Timestamp of the readiness check
	Timestamp time.Time `json:"timestamp"`

	// Version Service version (optional)
	Version *string `json:"version,omitempty"`
}

// ReadinessStatus The overall readiness status of the service
type ReadinessStatus string

// SystemInfo System resource information
type SystemInfo struct {
	// CpuCores Number of CPU cores available
	CpuCores *int `json:"cpuCores,omitempty"`

	// Goroutines Number of active goroutines
	Goroutines *int `json:"goroutines,omitempty"`

	// Memory Memory usage information
	Memory *MemoryInfo `json:"memory,omitempty"`
}

// UpdateDevice Request body for fully updating a device (PUT)
type UpdateDevice struct {
	// Brand The brand/manufacturer of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Brand string `json:"brand"`

	// Name The name of the device.
	// **Note:** Cannot be updated if the device state is "in-use"
	Name string `json:"name"`

	// State The current state of the device
	State DeviceState `json:"state"`
}

// UptimeInfo Service uptime information
type UptimeInfo struct {
	// Duration Human-readable uptime duration
	Duration string `json:"duration"`

	// DurationSeconds Uptime in seconds
	DurationSeconds *int `json:"durationSeconds,omitempty"`

	// StartedAt Timestamp when the service started
	StartedAt time.Time `json:"startedAt"`
}

// VersionInfo Version information about the service
type VersionInfo struct {
	// Api API version
	Api string `json:"api"`

	// Build Build version or commit hash
	Build string `json:"build"`

	// Go Go runtime version
	Go *string `json:"go,omitempty"`
}

// AcceptEncodingHeader defines model for AcceptEncodingHeader.
type AcceptEncodingHeader = string

// AcceptHeader defines model for AcceptHeader.
type AcceptHeader = string

// ApiVersionHeader defines model for ApiVersionHeader.
type ApiVersionHeader string

// AuthorizationHeader defines model for AuthorizationHeader.
type AuthorizationHeader = string

// BrandFilterParam defines model for BrandFilterParam.
type BrandFilterParam = []string

// CachePatternParam defines model for CachePatternParam.
type CachePatternParam = string

// CursorParam defines model for CursorParam.
type CursorParam = string

// DeviceIdParam defines model for DeviceIdParam.
type DeviceIdParam = openapi_types.UUID

// FieldsParam defines model for FieldsParam.
type FieldsParam = string

// IdempotencyKeyHeader defines model for IdempotencyKeyHeader.
type IdempotencyKeyHeader = openapi_types.UUID

// IfMatchHeader defines model for IfMatchHeader.
type IfMatchHeader = string

// IfNoneMatchHeader defines model for IfNoneMatchHeader.
type IfNoneMatchHeader = string

// PageParam defines model for PageParam.
type PageParam = int

// RequestIdHeader defines model for RequestIdHeader.
type RequestIdHeader = openapi_types.UUID

// SearchParam defines model for SearchParam.
type SearchParam = string

// SizeParam defines model for SizeParam.
type SizeParam = int

// SortParam defines model for SortParam.
type SortParam = []string

// StateFilterParam defines model for StateFilterParam.
type StateFilterParam = []DeviceState

// TraceparentHeader defines model for TraceparentHeader.
type TraceparentHeader = string

// TracestateHeader defines model for TracestateHeader.
type TracestateHeader = string

// BadRequest Standard error response format
type BadRequest = Error

// CacheBadRequest Error response for cache operations
type CacheBadRequest = CacheError

// CacheHealthOk Cache health status response
type CacheHealthOk = CacheHealth

// CacheHealthUnavailable Cache health status response
type CacheHealthUnavailable = CacheHealth

// CachePurgeAllDevices Response after purging cache entries
type CachePurgeAllDevices = CachePurge

// CachePurgeDevice Response after purging cache entries
type CachePurgeDevice = CachePurge

// CachePurgeLists Response after purging cache entries
type CachePurgeLists = CachePurge

// CachePurgePattern Response after purging cache entries by pattern
type CachePurgePattern = CachePatternPurge

// CacheServerError Error response for cache operations
type CacheServerError = CacheError

// CacheUnavailable Error response for cache operations
type CacheUnavailable = CacheError

// Conflict Standard error response format
type Conflict = Error

// DeviceCreated Response envelope containing a single device with metadata
type DeviceCreated = DeviceEnvelope

// DeviceRetrieved Response envelope containing a single device with metadata
type DeviceRetrieved = DeviceEnvelope

// DeviceUpdated Response envelope containing a single device with metadata
type DeviceUpdated = DeviceEnvelope

// DevicesList Response envelope containing a paginated list of devices with metadata
type DevicesList = DevicesListEnvelope

// HealthDown Comprehensive health check response with system metrics
type HealthDown = Health

// HealthOk Comprehensive health check response with system metrics
type HealthOk = Health

// LivenessDown Liveness probe response
type LivenessDown = Liveness

// LivenessOk Liveness probe response
type LivenessOk = Liveness

// NotAcceptable Standard error response format
type NotAcceptable = Error

// NotFound Standard error response format
type NotFound = Error

// PreconditionFailed Standard error response format
type PreconditionFailed = Error

// RateLimit Standard error response format
type RateLimit = Error

// ReadinessDown Readiness probe response with dependency status
type ReadinessDown = Readiness

// ReadinessOk Readiness probe response with dependency status
type ReadinessOk = Readiness

// ServerError Standard error response format
type ServerError = Error

// Unauthorized Standard error response format
type Unauthorized = Error

// UnprocessableEntity Standard error response format
type UnprocessableEntity = Error

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter by brand(s). Comma-separated for OR matching.
	// Example: ?brand=Apple,Samsung
	Brand *BrandFilterParam `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter by state(s). Comma-separated for OR matching.
	// Example: ?state=available,inactive
	State *StateFilterParam `form:"state,omitempty" json:"state,omitempty"`

	// Sort Fields to sort results by. Comma-separated for multi-field sorting.
	// Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	// Example: ?sort=-createdAt,name (sort by createdAt DESC, then name ASC)
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Q Full-text search query across name and brand fields.
	// Uses PostgreSQL full-text search with English language stemming.
	//
	// **Features:**
	// - Matches word variations (e.g., "running" matches "run")
	// - Case-insensitive search
	// - Searches both name and brand fields
	//
	// **Examples:**
	// - `?q=iPhone` - matches "iPhone 15 Pro", "My iPhone", etc.
	// - `?q=Samsung` - matches devices with Samsung brand
	// - `?q=Galaxy` - matches "Galaxy S24", "Galaxy Tab", etc.
	//
	// **Combining with filters:**
	// - `?q=iPhone&state=available` - available iPhones only
	// - `?q=Pro&brand=Apple` - Apple devices with "Pro" in name
	Q *SearchParam `form:"q,omitempty" json:"q,omitempty"`

	// Cursor Opaque cursor for keyset-based pagination.
	// When provided, the `page` parameter is ignored.
	//
	// **Usage:**
	// 1. First request: Don't include cursor (uses page-based pagination)
	// 2. Subsequent requests: Use `pagination.nextCursor` or `pagination.previousCursor` from previous response
	//
	// **Benefits over offset pagination:**
	// - Stable results even when data changes between requests
	// - Better performance for large datasets (no OFFSET scanning)
	// - Consistent page sizes
	//
	// **Note:** Cursors are opaque strings - do not parse or modify them.
	Cursor *CursorParam `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *FieldsParam `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *IfNoneMatchHeader `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *AcceptEncodingHeader `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// HeadDevicesParams defines parameters for HeadDevices.
type HeadDevicesParams struct {
	// Page Page number for pagination (1-indexed)
	Page *PageParam `form:"page,omitempty" json:"page,omitempty"`

	// Size Number of items per page
	Size *SizeParam `form:"size,omitempty" json:"size,omitempty"`

	// Brand Filter by brand(s). Comma-separated for OR matching.
	// Example: ?brand=Apple,Samsung
	Brand *BrandFilterParam `form:"brand,omitempty" json:"brand,omitempty"`

	// State Filter by state(s). Comma-separated for OR matching.
	// Example: ?state=available,inactive
	State *StateFilterParam `form:"state,omitempty" json:"state,omitempty"`

	// Sort Fields to sort results by. Comma-separated for multi-field sorting.
	// Prefix with `-` for descending order.
	// Supported fields: name, brand, state, createdAt, updatedAt
	// Example: ?sort=-createdAt,name (sort by createdAt DESC, then name ASC)
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Q Full-text search query across name and brand fields.
	// Uses PostgreSQL full-text search with English language stemming.
	//
	// **Features:**
	// - Matches word variations (e.g., "running" matches "run")
	// - Case-insensitive search
	// - Searches both name and brand fields
	//
	// **Examples:**
	// - `?q=iPhone` - matches "iPhone 15 Pro", "My iPhone", etc.
	// - `?q=Samsung` - matches devices with Samsung brand
	// - `?q=Galaxy` - matches "Galaxy S24", "Galaxy Tab", etc.
	//
	// **Combining with filters:**
	// - `?q=iPhone&state=available` - available iPhones only
	// - `?q=Pro&brand=Apple` - Apple devices with "Pro" in name
	Q *SearchParam `form:"q,omitempty" json:"q,omitempty"`

	// Cursor Opaque cursor for keyset-based pagination.
	// When provided, the `page` parameter is ignored.
	//
	// **Usage:**
	// 1. First request: Don't include cursor (uses page-based pagination)
	// 2. Subsequent requests: Use `pagination.nextCursor` or `pagination.previousCursor` from previous response
	//
	// **Benefits over offset pagination:**
	// - Stable results even when data changes between requests
	// - Better performance for large datasets (no OFFSET scanning)
	// - Consistent page sizes
	//
	// **Note:** Cursors are opaque strings - do not parse or modify them.
	Cursor *CursorParam `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *IfNoneMatchHeader `json:"If-None-Match,omitempty"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// OptionsDevicesParams defines parameters for OptionsDevices.
type OptionsDevicesParams struct {
	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// CreateDeviceParams defines parameters for CreateDevice.
type CreateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// IdempotencyKey Unique key to ensure idempotent POST requests.
	// If the same key is sent again within the TTL window (24 hours),
	// the server returns the cached response instead of creating a duplicate.
	//
	// **Requirements:**
	// - Must be a valid UUID v7
	// - Must be unique per logical operation
	// - Cached for 24 hours
	IdempotencyKey IdempotencyKeyHeader `json:"Idempotency-Key"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// DeleteDeviceParams defines parameters for DeleteDevice.
type DeleteDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// GetDeviceParams defines parameters for GetDevice.
type GetDeviceParams struct {
	// Fields Field projection to control which fields are returned in the response.
	//
	// **Default behavior (no fields parameter):**
	// Returns essential fields only: `id`, `name`, `brand`, `state`
	//
	// **With fields parameter:**
	// Returns only the specified fields. Use comma-separated list.
	//
	// **Supported fields:**
	// - `id` - Device unique identifier (always included)
	// - `name` - Device name
	// - `brand` - Device manufacturer
	// - `state` - Device state (available, in-use, inactive)
	// - `createdAt` - Creation timestamp
	// - `updatedAt` - Last update timestamp
	// - `links` - HATEOAS navigation links
	//
	// **Nested fields syntax:**
	// Use `field:(subfield1,subfield2)` for nested objects.
	// Example: `links:(self)` returns only the self link.
	Fields *FieldsParam `form:"fields,omitempty" json:"fields,omitempty"`

	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *IfNoneMatchHeader `json:"If-None-Match,omitempty"`

	// AcceptEncoding Accepted compression algorithms for the response.
	// Server will use the best matching algorithm.
	AcceptEncoding *AcceptEncodingHeader `json:"Accept-Encoding,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// HeadDeviceParams defines parameters for HeadDevice.
type HeadDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// IfNoneMatch ETag value for conditional requests.
	// For GET: Returns 304 Not Modified if the resource hasn't changed.
	// For PUT/PATCH: Prevents updates if resource exists (use "*").
	IfNoneMatch *IfNoneMatchHeader `json:"If-None-Match,omitempty"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// OptionsDeviceParams defines parameters for OptionsDevice.
type OptionsDeviceParams struct {
	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// PatchDeviceParams defines parameters for PatchDevice.
type PatchDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *IfMatchHeader `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// UpdateDeviceParams defines parameters for UpdateDevice.
type UpdateDeviceParams struct {
	// Authorization PASETO v4 bearer token for authentication.
	// Format: Bearer v4.public.{payload}.{signature}
	Authorization AuthorizationHeader `json:"Authorization"`

	// IfMatch ETag value for optimistic concurrency control.
	// The request will only succeed if the current resource ETag matches this value.
	IfMatch *IfMatchHeader `json:"If-Match,omitempty"`

	// Accept Media type(s) acceptable for the response.
	// Currently only `application/json` is supported.
	//
	// If not specified, defaults to `application/json`.
	// If an unsupported media type is requested, returns 406 Not Acceptable.
	Accept *AcceptHeader `json:"Accept,omitempty"`

	// APIVersion API version to use for this request. If not specified, defaults to v1.
	// Supported versions: v1
	APIVersion *ApiVersionHeader `json:"API-Version,omitempty"`

	// RequestId Unique request identifier for tracing and debugging purposes (per-request, always generated server-side).
	// RFC 6648 compliant (no X- prefix).
	RequestId *RequestIdHeader `json:"Request-Id,omitempty"`

	// Traceparent W3C Trace Context header for distributed tracing (OpenTelemetry compatible).
	//
	// Format: `{version}-{trace-id}-{parent-id}-{trace-flags}`
	// - version: 2 hex digits (always "00")
	// - trace-id: 32 hex digits (16 bytes)
	// - parent-id: 16 hex digits (8 bytes)
	// - trace-flags: 2 hex digits (sampling flag)
	//
	// If not provided, the server will generate a new trace context.
	Traceparent *TraceparentHeader `json:"traceparent,omitempty"`

	// Tracestate W3C Trace Context state header for vendor-specific trace data.
	// Comma-separated list of key=value pairs.
	Tracestate *TracestateHeader `json:"tracestate,omitempty"`
}

// CreateDeviceJSONRequestBody defines body for CreateDevice for application/json ContentType.
type CreateDeviceJSONRequestBody = CreateDevice

// PatchDeviceJSONRequestBody defines body for PatchDevice for application/json ContentType.
type PatchDeviceJSONRequestBody = PatchDevice

// UpdateDeviceJSONRequestBody defines body for UpdateDevice for application/json ContentType.
type UpdateDeviceJSONRequestBody = UpdateDevice

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all devices
	// (GET /devices)
	ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams)
	// Get devices collection metadata
	// (HEAD /devices)
	HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams)
	// Get allowed methods for devices collection
	// (OPTIONS /devices)
	OptionsDevices(w http.ResponseWriter, r *http.Request, params OptionsDevicesParams)
	// Create a new device
	// (POST /devices)
	CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams)
	// Delete a device
	// (DELETE /devices/{deviceId})
	DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params DeleteDeviceParams)
	// Get a device by ID
	// (GET /devices/{deviceId})
	GetDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params GetDeviceParams)
	// Get device metadata
	// (HEAD /devices/{deviceId})
	HeadDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params HeadDeviceParams)
	// Get allowed methods for device resource
	// (OPTIONS /devices/{deviceId})
	OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params OptionsDeviceParams)
	// Partially update a device
	// (PATCH /devices/{deviceId})
	PatchDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params PatchDeviceParams)
	// Fully update a device
	// (PUT /devices/{deviceId})
	UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params UpdateDeviceParams)
	// Health check
	// (GET /health)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// Liveness probe
	// (GET /liveness)
	LivenessCheck(w http.ResponseWriter, r *http.Request)
	// Readiness probe
	// (GET /readiness)
	ReadinessCheck(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List all devices
// (GET /devices)
func (_ Unimplemented) ListDevices(w http.ResponseWriter, r *http.Request, params ListDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get devices collection metadata
// (HEAD /devices)
func (_ Unimplemented) HeadDevices(w http.ResponseWriter, r *http.Request, params HeadDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for devices collection
// (OPTIONS /devices)
func (_ Unimplemented) OptionsDevices(w http.ResponseWriter, r *http.Request, params OptionsDevicesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new device
// (POST /devices)
func (_ Unimplemented) CreateDevice(w http.ResponseWriter, r *http.Request, params CreateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a device
// (DELETE /devices/{deviceId})
func (_ Unimplemented) DeleteDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params DeleteDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a device by ID
// (GET /devices/{deviceId})
func (_ Unimplemented) GetDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params GetDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get device metadata
// (HEAD /devices/{deviceId})
func (_ Unimplemented) HeadDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params HeadDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get allowed methods for device resource
// (OPTIONS /devices/{deviceId})
func (_ Unimplemented) OptionsDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params OptionsDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Partially update a device
// (PATCH /devices/{deviceId})
func (_ Unimplemented) PatchDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params PatchDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Fully update a device
// (PUT /devices/{deviceId})
func (_ Unimplemented) UpdateDevice(w http.ResponseWriter, r *http.Request, deviceId DeviceIdParam, params UpdateDeviceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Health check
// (GET /health)
func (_ Unimplemented) HealthCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Liveness probe
// (GET /liveness)
func (_ Unimplemented) LivenessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Readiness probe
// (GET /readiness)
func (_ Unimplemented) ReadinessCheck(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", false, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding AcceptEncodingHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevices operation middleware
func (siw *ServerInterfaceWrapper) HeadDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDevicesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", r.URL.Query(), &params.Size)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "size", Err: err})
		return
	}

	// ------------- Optional query parameter "brand" -------------

	err = runtime.BindQueryParameter("form", false, false, "brand", r.URL.Query(), &params.Brand)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "brand", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", false, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", r.URL.Query(), &params.Cursor)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cursor", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevices operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevices(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params OptionsDevicesParams

	headers := r.Header

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevices(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateDevice operation middleware
func (siw *ServerInterfaceWrapper) CreateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Required header parameter "Idempotency-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Idempotency-Key")]; found {
		var IdempotencyKey IdempotencyKeyHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Idempotency-Key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Idempotency-Key", valueList[0], &IdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Idempotency-Key", Err: err})
			return
		}

		params.IdempotencyKey = IdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter Idempotency-Key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Idempotency-Key", Err: err})
		return
	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDevice(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDevice operation middleware
func (siw *ServerInterfaceWrapper) DeleteDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDevice operation middleware
func (siw *ServerInterfaceWrapper) GetDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDeviceParams

	// ------------- Optional query parameter "fields" -------------

	err = runtime.BindQueryParameter("form", true, false, "fields", r.URL.Query(), &params.Fields)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fields", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "Accept-Encoding" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept-Encoding")]; found {
		var AcceptEncoding AcceptEncodingHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept-Encoding", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept-Encoding", valueList[0], &AcceptEncoding, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept-Encoding", Err: err})
			return
		}

		params.AcceptEncoding = &AcceptEncoding

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDevice operation middleware
func (siw *ServerInterfaceWrapper) HeadDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-None-Match", valueList[0], &IfNoneMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// OptionsDevice operation middleware
func (siw *ServerInterfaceWrapper) OptionsDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params OptionsDeviceParams

	headers := r.Header

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.OptionsDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PatchDevice operation middleware
func (siw *ServerInterfaceWrapper) PatchDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateDevice operation middleware
func (siw *ServerInterfaceWrapper) UpdateDevice(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "deviceId" -------------
	var deviceId DeviceIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "deviceId", chi.URLParam(r, "deviceId"), &deviceId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "deviceId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, PasetoAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateDeviceParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization AuthorizationHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch IfMatchHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	// ------------- Optional header parameter "Accept" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Accept")]; found {
		var Accept AcceptHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Accept", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Accept", valueList[0], &Accept, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Accept", Err: err})
			return
		}

		params.Accept = &Accept

	}

	// ------------- Optional header parameter "API-Version" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("API-Version")]; found {
		var APIVersion ApiVersionHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "API-Version", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "API-Version", valueList[0], &APIVersion, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "API-Version", Err: err})
			return
		}

		params.APIVersion = &APIVersion

	}

	// ------------- Optional header parameter "Request-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Request-Id")]; found {
		var RequestId RequestIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Request-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Request-Id", valueList[0], &RequestId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Request-Id", Err: err})
			return
		}

		params.RequestId = &RequestId

	}

	// ------------- Optional header parameter "traceparent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("traceparent")]; found {
		var Traceparent TraceparentHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "traceparent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "traceparent", valueList[0], &Traceparent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceparent", Err: err})
			return
		}

		params.Traceparent = &Traceparent

	}

	// ------------- Optional header parameter "tracestate" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("tracestate")]; found {
		var Tracestate TracestateHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "tracestate", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "tracestate", valueList[0], &Tracestate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tracestate", Err: err})
			return
		}

		params.Tracestate = &Tracestate

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDevice(w, r, deviceId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LivenessCheck operation middleware
func (siw *ServerInterfaceWrapper) LivenessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LivenessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadinessCheck operation middleware
func (siw *ServerInterfaceWrapper) ReadinessCheck(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadinessCheck(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices", wrapper.ListDevices)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices", wrapper.HeadDevices)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices", wrapper.OptionsDevices)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/devices", wrapper.CreateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/devices/{deviceId}", wrapper.DeleteDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/devices/{deviceId}", wrapper.GetDevice)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/devices/{deviceId}", wrapper.HeadDevice)
	})
	r.Group(func(r chi.Router) {
		r.Options(options.BaseURL+"/devices/{deviceId}", wrapper.OptionsDevice)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/devices/{deviceId}", wrapper.PatchDevice)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/devices/{deviceId}", wrapper.UpdateDevice)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/health", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/liveness", wrapper.LivenessCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/readiness", wrapper.ReadinessCheck)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
